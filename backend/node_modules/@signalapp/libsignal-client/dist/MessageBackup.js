"use strict";
//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.Purpose = exports.MessageBackupKey = exports.ValidationOutcome = void 0;
/**
 * Message backup validation routines.
 *
 * @module MessageBackup
 */
const Native = require("../Native");
/**
 * Result of validating a message backup bundle.
 */
class ValidationOutcome {
    /**
     * `true` if the backup is valid, `false` otherwise.
     *
     * If this is `true`, there might still be messages about unknown fields.
     */
    get ok() {
        return this.errorMessage == null;
    }
    constructor(outcome) {
        const { errorMessage, unknownFieldMessages } = outcome;
        this.errorMessage = errorMessage;
        this.unknownFieldMessages = unknownFieldMessages;
    }
}
exports.ValidationOutcome = ValidationOutcome;
/**
 * Key used to encrypt and decrypt a message backup bundle.
 */
class MessageBackupKey {
    /**
     * Create a public key from the given master key and ACI.
     *
     * `masterKeyBytes` should contain exactly 32 bytes.
     */
    constructor(masterKeyBytes, aci) {
        this._nativeHandle = Native.MessageBackupKey_New(masterKeyBytes, aci.getServiceIdFixedWidthBinary());
    }
}
exports.MessageBackupKey = MessageBackupKey;
// This must match the Rust version of the enum.
var Purpose;
(function (Purpose) {
    Purpose[Purpose["DeviceTransfer"] = 0] = "DeviceTransfer";
    Purpose[Purpose["RemoteBackup"] = 1] = "RemoteBackup";
})(Purpose = exports.Purpose || (exports.Purpose = {}));
/**
 * Validate a backup file
 *
 * @param backupKey The key to use to decrypt the backup contents.
 * @param purpose Whether the backup is intended for device-to-device transfer or remote storage.
 * @param inputFactory A function that returns new input streams that read the backup contents.
 * @param length The exact length of the input stream.
 * @returns The outcome of validation, including any errors and warnings.
 * @throws IoError If an IO error on the input occurs.
 */
async function validate(backupKey, purpose, inputFactory, length) {
    const firstStream = inputFactory();
    const secondStream = inputFactory();
    return new ValidationOutcome(await Native.MessageBackupValidator_Validate(backupKey, firstStream, secondStream, length, purpose));
}
exports.validate = validate;
//# sourceMappingURL=MessageBackup.js.map