
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PrekeyBundle
 * 
 */
export type PrekeyBundle = $Result.DefaultSelection<Prisma.$PrekeyBundlePayload>
/**
 * Model SignedPrekey
 * 
 */
export type SignedPrekey = $Result.DefaultSelection<Prisma.$SignedPrekeyPayload>
/**
 * Model SessionState
 * 
 */
export type SessionState = $Result.DefaultSelection<Prisma.$SessionStatePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model UserContact
 * 
 */
export type UserContact = $Result.DefaultSelection<Prisma.$UserContactPayload>
/**
 * Model MediaFile
 * 
 */
export type MediaFile = $Result.DefaultSelection<Prisma.$MediaFilePayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model OtpAttempt
 * 
 */
export type OtpAttempt = $Result.DefaultSelection<Prisma.$OtpAttemptPayload>
/**
 * Model SignalIdentity
 * 
 */
export type SignalIdentity = $Result.DefaultSelection<Prisma.$SignalIdentityPayload>
/**
 * Model SignalSession
 * 
 */
export type SignalSession = $Result.DefaultSelection<Prisma.$SignalSessionPayload>
/**
 * Model SenderKey
 * 
 */
export type SenderKey = $Result.DefaultSelection<Prisma.$SenderKeyPayload>
/**
 * Model SignalMessageMetadata
 * 
 */
export type SignalMessageMetadata = $Result.DefaultSelection<Prisma.$SignalMessageMetadataPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model DeletedMessage
 * 
 */
export type DeletedMessage = $Result.DefaultSelection<Prisma.$DeletedMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT',
  LOCATION: 'LOCATION',
  CONTACT: 'CONTACT',
  STICKER: 'STICKER'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const MessageStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const GroupMemberRole: {
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type GroupMemberRole = (typeof GroupMemberRole)[keyof typeof GroupMemberRole]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type GroupMemberRole = $Enums.GroupMemberRole

export const GroupMemberRole: typeof $Enums.GroupMemberRole

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.prekeyBundle`: Exposes CRUD operations for the **PrekeyBundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrekeyBundles
    * const prekeyBundles = await prisma.prekeyBundle.findMany()
    * ```
    */
  get prekeyBundle(): Prisma.PrekeyBundleDelegate<ExtArgs>;

  /**
   * `prisma.signedPrekey`: Exposes CRUD operations for the **SignedPrekey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignedPrekeys
    * const signedPrekeys = await prisma.signedPrekey.findMany()
    * ```
    */
  get signedPrekey(): Prisma.SignedPrekeyDelegate<ExtArgs>;

  /**
   * `prisma.sessionState`: Exposes CRUD operations for the **SessionState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionStates
    * const sessionStates = await prisma.sessionState.findMany()
    * ```
    */
  get sessionState(): Prisma.SessionStateDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs>;

  /**
   * `prisma.userContact`: Exposes CRUD operations for the **UserContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContacts
    * const userContacts = await prisma.userContact.findMany()
    * ```
    */
  get userContact(): Prisma.UserContactDelegate<ExtArgs>;

  /**
   * `prisma.mediaFile`: Exposes CRUD operations for the **MediaFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaFiles
    * const mediaFiles = await prisma.mediaFile.findMany()
    * ```
    */
  get mediaFile(): Prisma.MediaFileDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.otpAttempt`: Exposes CRUD operations for the **OtpAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtpAttempts
    * const otpAttempts = await prisma.otpAttempt.findMany()
    * ```
    */
  get otpAttempt(): Prisma.OtpAttemptDelegate<ExtArgs>;

  /**
   * `prisma.signalIdentity`: Exposes CRUD operations for the **SignalIdentity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignalIdentities
    * const signalIdentities = await prisma.signalIdentity.findMany()
    * ```
    */
  get signalIdentity(): Prisma.SignalIdentityDelegate<ExtArgs>;

  /**
   * `prisma.signalSession`: Exposes CRUD operations for the **SignalSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignalSessions
    * const signalSessions = await prisma.signalSession.findMany()
    * ```
    */
  get signalSession(): Prisma.SignalSessionDelegate<ExtArgs>;

  /**
   * `prisma.senderKey`: Exposes CRUD operations for the **SenderKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SenderKeys
    * const senderKeys = await prisma.senderKey.findMany()
    * ```
    */
  get senderKey(): Prisma.SenderKeyDelegate<ExtArgs>;

  /**
   * `prisma.signalMessageMetadata`: Exposes CRUD operations for the **SignalMessageMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignalMessageMetadata
    * const signalMessageMetadata = await prisma.signalMessageMetadata.findMany()
    * ```
    */
  get signalMessageMetadata(): Prisma.SignalMessageMetadataDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.deletedMessage`: Exposes CRUD operations for the **DeletedMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedMessages
    * const deletedMessages = await prisma.deletedMessage.findMany()
    * ```
    */
  get deletedMessage(): Prisma.DeletedMessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    PrekeyBundle: 'PrekeyBundle',
    SignedPrekey: 'SignedPrekey',
    SessionState: 'SessionState',
    Message: 'Message',
    Group: 'Group',
    GroupMember: 'GroupMember',
    UserContact: 'UserContact',
    MediaFile: 'MediaFile',
    RefreshToken: 'RefreshToken',
    OtpAttempt: 'OtpAttempt',
    SignalIdentity: 'SignalIdentity',
    SignalSession: 'SignalSession',
    SenderKey: 'SenderKey',
    SignalMessageMetadata: 'SignalMessageMetadata',
    Contact: 'Contact',
    DeletedMessage: 'DeletedMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "prekeyBundle" | "signedPrekey" | "sessionState" | "message" | "group" | "groupMember" | "userContact" | "mediaFile" | "refreshToken" | "otpAttempt" | "signalIdentity" | "signalSession" | "senderKey" | "signalMessageMetadata" | "contact" | "deletedMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PrekeyBundle: {
        payload: Prisma.$PrekeyBundlePayload<ExtArgs>
        fields: Prisma.PrekeyBundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrekeyBundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrekeyBundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          findFirst: {
            args: Prisma.PrekeyBundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrekeyBundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          findMany: {
            args: Prisma.PrekeyBundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>[]
          }
          create: {
            args: Prisma.PrekeyBundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          createMany: {
            args: Prisma.PrekeyBundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrekeyBundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>[]
          }
          delete: {
            args: Prisma.PrekeyBundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          update: {
            args: Prisma.PrekeyBundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          deleteMany: {
            args: Prisma.PrekeyBundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrekeyBundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrekeyBundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrekeyBundlePayload>
          }
          aggregate: {
            args: Prisma.PrekeyBundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrekeyBundle>
          }
          groupBy: {
            args: Prisma.PrekeyBundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrekeyBundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrekeyBundleCountArgs<ExtArgs>
            result: $Utils.Optional<PrekeyBundleCountAggregateOutputType> | number
          }
        }
      }
      SignedPrekey: {
        payload: Prisma.$SignedPrekeyPayload<ExtArgs>
        fields: Prisma.SignedPrekeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignedPrekeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignedPrekeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          findFirst: {
            args: Prisma.SignedPrekeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignedPrekeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          findMany: {
            args: Prisma.SignedPrekeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>[]
          }
          create: {
            args: Prisma.SignedPrekeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          createMany: {
            args: Prisma.SignedPrekeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignedPrekeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>[]
          }
          delete: {
            args: Prisma.SignedPrekeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          update: {
            args: Prisma.SignedPrekeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          deleteMany: {
            args: Prisma.SignedPrekeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignedPrekeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignedPrekeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignedPrekeyPayload>
          }
          aggregate: {
            args: Prisma.SignedPrekeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignedPrekey>
          }
          groupBy: {
            args: Prisma.SignedPrekeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignedPrekeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignedPrekeyCountArgs<ExtArgs>
            result: $Utils.Optional<SignedPrekeyCountAggregateOutputType> | number
          }
        }
      }
      SessionState: {
        payload: Prisma.$SessionStatePayload<ExtArgs>
        fields: Prisma.SessionStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          findFirst: {
            args: Prisma.SessionStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          findMany: {
            args: Prisma.SessionStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>[]
          }
          create: {
            args: Prisma.SessionStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          createMany: {
            args: Prisma.SessionStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>[]
          }
          delete: {
            args: Prisma.SessionStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          update: {
            args: Prisma.SessionStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          deleteMany: {
            args: Prisma.SessionStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStatePayload>
          }
          aggregate: {
            args: Prisma.SessionStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionState>
          }
          groupBy: {
            args: Prisma.SessionStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionStateCountArgs<ExtArgs>
            result: $Utils.Optional<SessionStateCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      UserContact: {
        payload: Prisma.$UserContactPayload<ExtArgs>
        fields: Prisma.UserContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          findFirst: {
            args: Prisma.UserContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          findMany: {
            args: Prisma.UserContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>[]
          }
          create: {
            args: Prisma.UserContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          createMany: {
            args: Prisma.UserContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>[]
          }
          delete: {
            args: Prisma.UserContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          update: {
            args: Prisma.UserContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          deleteMany: {
            args: Prisma.UserContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          aggregate: {
            args: Prisma.UserContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserContact>
          }
          groupBy: {
            args: Prisma.UserContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserContactCountArgs<ExtArgs>
            result: $Utils.Optional<UserContactCountAggregateOutputType> | number
          }
        }
      }
      MediaFile: {
        payload: Prisma.$MediaFilePayload<ExtArgs>
        fields: Prisma.MediaFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findFirst: {
            args: Prisma.MediaFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findMany: {
            args: Prisma.MediaFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          create: {
            args: Prisma.MediaFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          createMany: {
            args: Prisma.MediaFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          delete: {
            args: Prisma.MediaFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          update: {
            args: Prisma.MediaFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          deleteMany: {
            args: Prisma.MediaFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          aggregate: {
            args: Prisma.MediaFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaFile>
          }
          groupBy: {
            args: Prisma.MediaFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaFileCountArgs<ExtArgs>
            result: $Utils.Optional<MediaFileCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      OtpAttempt: {
        payload: Prisma.$OtpAttemptPayload<ExtArgs>
        fields: Prisma.OtpAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          findFirst: {
            args: Prisma.OtpAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          findMany: {
            args: Prisma.OtpAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>[]
          }
          create: {
            args: Prisma.OtpAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          createMany: {
            args: Prisma.OtpAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>[]
          }
          delete: {
            args: Prisma.OtpAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          update: {
            args: Prisma.OtpAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          deleteMany: {
            args: Prisma.OtpAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpAttemptPayload>
          }
          aggregate: {
            args: Prisma.OtpAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtpAttempt>
          }
          groupBy: {
            args: Prisma.OtpAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<OtpAttemptCountAggregateOutputType> | number
          }
        }
      }
      SignalIdentity: {
        payload: Prisma.$SignalIdentityPayload<ExtArgs>
        fields: Prisma.SignalIdentityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalIdentityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalIdentityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          findFirst: {
            args: Prisma.SignalIdentityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalIdentityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          findMany: {
            args: Prisma.SignalIdentityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>[]
          }
          create: {
            args: Prisma.SignalIdentityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          createMany: {
            args: Prisma.SignalIdentityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalIdentityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>[]
          }
          delete: {
            args: Prisma.SignalIdentityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          update: {
            args: Prisma.SignalIdentityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          deleteMany: {
            args: Prisma.SignalIdentityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalIdentityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignalIdentityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalIdentityPayload>
          }
          aggregate: {
            args: Prisma.SignalIdentityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignalIdentity>
          }
          groupBy: {
            args: Prisma.SignalIdentityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalIdentityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalIdentityCountArgs<ExtArgs>
            result: $Utils.Optional<SignalIdentityCountAggregateOutputType> | number
          }
        }
      }
      SignalSession: {
        payload: Prisma.$SignalSessionPayload<ExtArgs>
        fields: Prisma.SignalSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          findFirst: {
            args: Prisma.SignalSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          findMany: {
            args: Prisma.SignalSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>[]
          }
          create: {
            args: Prisma.SignalSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          createMany: {
            args: Prisma.SignalSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>[]
          }
          delete: {
            args: Prisma.SignalSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          update: {
            args: Prisma.SignalSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          deleteMany: {
            args: Prisma.SignalSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignalSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalSessionPayload>
          }
          aggregate: {
            args: Prisma.SignalSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignalSession>
          }
          groupBy: {
            args: Prisma.SignalSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SignalSessionCountAggregateOutputType> | number
          }
        }
      }
      SenderKey: {
        payload: Prisma.$SenderKeyPayload<ExtArgs>
        fields: Prisma.SenderKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SenderKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SenderKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          findFirst: {
            args: Prisma.SenderKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SenderKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          findMany: {
            args: Prisma.SenderKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>[]
          }
          create: {
            args: Prisma.SenderKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          createMany: {
            args: Prisma.SenderKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SenderKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>[]
          }
          delete: {
            args: Prisma.SenderKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          update: {
            args: Prisma.SenderKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          deleteMany: {
            args: Prisma.SenderKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SenderKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SenderKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderKeyPayload>
          }
          aggregate: {
            args: Prisma.SenderKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSenderKey>
          }
          groupBy: {
            args: Prisma.SenderKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SenderKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SenderKeyCountArgs<ExtArgs>
            result: $Utils.Optional<SenderKeyCountAggregateOutputType> | number
          }
        }
      }
      SignalMessageMetadata: {
        payload: Prisma.$SignalMessageMetadataPayload<ExtArgs>
        fields: Prisma.SignalMessageMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalMessageMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalMessageMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          findFirst: {
            args: Prisma.SignalMessageMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalMessageMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          findMany: {
            args: Prisma.SignalMessageMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>[]
          }
          create: {
            args: Prisma.SignalMessageMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          createMany: {
            args: Prisma.SignalMessageMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalMessageMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>[]
          }
          delete: {
            args: Prisma.SignalMessageMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          update: {
            args: Prisma.SignalMessageMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          deleteMany: {
            args: Prisma.SignalMessageMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalMessageMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignalMessageMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalMessageMetadataPayload>
          }
          aggregate: {
            args: Prisma.SignalMessageMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignalMessageMetadata>
          }
          groupBy: {
            args: Prisma.SignalMessageMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalMessageMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalMessageMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<SignalMessageMetadataCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      DeletedMessage: {
        payload: Prisma.$DeletedMessagePayload<ExtArgs>
        fields: Prisma.DeletedMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeletedMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeletedMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          findFirst: {
            args: Prisma.DeletedMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeletedMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          findMany: {
            args: Prisma.DeletedMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>[]
          }
          create: {
            args: Prisma.DeletedMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          createMany: {
            args: Prisma.DeletedMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeletedMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>[]
          }
          delete: {
            args: Prisma.DeletedMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          update: {
            args: Prisma.DeletedMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          deleteMany: {
            args: Prisma.DeletedMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeletedMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeletedMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedMessagePayload>
          }
          aggregate: {
            args: Prisma.DeletedMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeletedMessage>
          }
          groupBy: {
            args: Prisma.DeletedMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeletedMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeletedMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DeletedMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sentMessages: number
    receivedMessages: number
    prekeyBundles: number
    signedPrekeys: number
    signalIdentities: number
    groupMembers: number
    createdGroups: number
    userContacts: number
    contacts: number
    mediaFiles: number
    refreshTokens: number
    otpAttempts: number
    deletedMessages: number
    sessionStates: number
    ownedContacts: number
    contactedBy: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    prekeyBundles?: boolean | UserCountOutputTypeCountPrekeyBundlesArgs
    signedPrekeys?: boolean | UserCountOutputTypeCountSignedPrekeysArgs
    signalIdentities?: boolean | UserCountOutputTypeCountSignalIdentitiesArgs
    groupMembers?: boolean | UserCountOutputTypeCountGroupMembersArgs
    createdGroups?: boolean | UserCountOutputTypeCountCreatedGroupsArgs
    userContacts?: boolean | UserCountOutputTypeCountUserContactsArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    mediaFiles?: boolean | UserCountOutputTypeCountMediaFilesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    otpAttempts?: boolean | UserCountOutputTypeCountOtpAttemptsArgs
    deletedMessages?: boolean | UserCountOutputTypeCountDeletedMessagesArgs
    sessionStates?: boolean | UserCountOutputTypeCountSessionStatesArgs
    ownedContacts?: boolean | UserCountOutputTypeCountOwnedContactsArgs
    contactedBy?: boolean | UserCountOutputTypeCountContactedByArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrekeyBundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrekeyBundleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSignedPrekeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignedPrekeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSignalIdentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalIdentityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletedMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionStateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    replies: number
    deletedMessages: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | MessageCountOutputTypeCountRepliesArgs
    deletedMessages?: boolean | MessageCountOutputTypeCountDeletedMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountDeletedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletedMessageWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    messages: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    messages?: boolean | GroupCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MediaFileCountOutputType
   */

  export type MediaFileCountOutputType = {
    messages: number
  }

  export type MediaFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MediaFileCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * MediaFileCountOutputType without action
   */
  export type MediaFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFileCountOutputType
     */
    select?: MediaFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaFileCountOutputType without action
   */
  export type MediaFileCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    registrationId: number | null
  }

  export type UserSumAggregateOutputType = {
    registrationId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    countryCode: string | null
    identityKey: string | null
    registrationId: number | null
    name: string | null
    about: string | null
    avatarUrl: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    countryCode: string | null
    identityKey: string | null
    registrationId: number | null
    name: string | null
    about: string | null
    avatarUrl: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phoneNumber: number
    countryCode: number
    identityKey: number
    registrationId: number
    name: number
    about: number
    avatarUrl: number
    isOnline: number
    lastSeen: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    registrationId?: true
  }

  export type UserSumAggregateInputType = {
    registrationId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    countryCode?: true
    identityKey?: true
    registrationId?: true
    name?: true
    about?: true
    avatarUrl?: true
    isOnline?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    countryCode?: true
    identityKey?: true
    registrationId?: true
    name?: true
    about?: true
    avatarUrl?: true
    isOnline?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    countryCode?: true
    identityKey?: true
    registrationId?: true
    name?: true
    about?: true
    avatarUrl?: true
    isOnline?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name: string | null
    about: string | null
    avatarUrl: string | null
    isOnline: boolean
    lastSeen: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    identityKey?: boolean
    registrationId?: boolean
    name?: boolean
    about?: boolean
    avatarUrl?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    prekeyBundles?: boolean | User$prekeyBundlesArgs<ExtArgs>
    signedPrekeys?: boolean | User$signedPrekeysArgs<ExtArgs>
    signalIdentities?: boolean | User$signalIdentitiesArgs<ExtArgs>
    groupMembers?: boolean | User$groupMembersArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    userContacts?: boolean | User$userContactsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    mediaFiles?: boolean | User$mediaFilesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    otpAttempts?: boolean | User$otpAttemptsArgs<ExtArgs>
    deletedMessages?: boolean | User$deletedMessagesArgs<ExtArgs>
    sessionStates?: boolean | User$sessionStatesArgs<ExtArgs>
    ownedContacts?: boolean | User$ownedContactsArgs<ExtArgs>
    contactedBy?: boolean | User$contactedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    identityKey?: boolean
    registrationId?: boolean
    name?: boolean
    about?: boolean
    avatarUrl?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    identityKey?: boolean
    registrationId?: boolean
    name?: boolean
    about?: boolean
    avatarUrl?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    prekeyBundles?: boolean | User$prekeyBundlesArgs<ExtArgs>
    signedPrekeys?: boolean | User$signedPrekeysArgs<ExtArgs>
    signalIdentities?: boolean | User$signalIdentitiesArgs<ExtArgs>
    groupMembers?: boolean | User$groupMembersArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    userContacts?: boolean | User$userContactsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    mediaFiles?: boolean | User$mediaFilesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    otpAttempts?: boolean | User$otpAttemptsArgs<ExtArgs>
    deletedMessages?: boolean | User$deletedMessagesArgs<ExtArgs>
    sessionStates?: boolean | User$sessionStatesArgs<ExtArgs>
    ownedContacts?: boolean | User$ownedContactsArgs<ExtArgs>
    contactedBy?: boolean | User$contactedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      prekeyBundles: Prisma.$PrekeyBundlePayload<ExtArgs>[]
      signedPrekeys: Prisma.$SignedPrekeyPayload<ExtArgs>[]
      signalIdentities: Prisma.$SignalIdentityPayload<ExtArgs>[]
      groupMembers: Prisma.$GroupMemberPayload<ExtArgs>[]
      createdGroups: Prisma.$GroupPayload<ExtArgs>[]
      userContacts: Prisma.$ContactPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      mediaFiles: Prisma.$MediaFilePayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      otpAttempts: Prisma.$OtpAttemptPayload<ExtArgs>[]
      deletedMessages: Prisma.$DeletedMessagePayload<ExtArgs>[]
      sessionStates: Prisma.$SessionStatePayload<ExtArgs>[]
      ownedContacts: Prisma.$UserContactPayload<ExtArgs>[]
      contactedBy: Prisma.$UserContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      countryCode: string
      identityKey: string
      registrationId: number
      name: string | null
      about: string | null
      avatarUrl: string | null
      isOnline: boolean
      lastSeen: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    prekeyBundles<T extends User$prekeyBundlesArgs<ExtArgs> = {}>(args?: Subset<T, User$prekeyBundlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findMany"> | Null>
    signedPrekeys<T extends User$signedPrekeysArgs<ExtArgs> = {}>(args?: Subset<T, User$signedPrekeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findMany"> | Null>
    signalIdentities<T extends User$signalIdentitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$signalIdentitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findMany"> | Null>
    groupMembers<T extends User$groupMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    createdGroups<T extends User$createdGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    userContacts<T extends User$userContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$userContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    mediaFiles<T extends User$mediaFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    otpAttempts<T extends User$otpAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    deletedMessages<T extends User$deletedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$deletedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findMany"> | Null>
    sessionStates<T extends User$sessionStatesArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findMany"> | Null>
    ownedContacts<T extends User$ownedContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findMany"> | Null>
    contactedBy<T extends User$contactedByArgs<ExtArgs> = {}>(args?: Subset<T, User$contactedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly identityKey: FieldRef<"User", 'String'>
    readonly registrationId: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly about: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly lastSeen: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.prekeyBundles
   */
  export type User$prekeyBundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    where?: PrekeyBundleWhereInput
    orderBy?: PrekeyBundleOrderByWithRelationInput | PrekeyBundleOrderByWithRelationInput[]
    cursor?: PrekeyBundleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrekeyBundleScalarFieldEnum | PrekeyBundleScalarFieldEnum[]
  }

  /**
   * User.signedPrekeys
   */
  export type User$signedPrekeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    where?: SignedPrekeyWhereInput
    orderBy?: SignedPrekeyOrderByWithRelationInput | SignedPrekeyOrderByWithRelationInput[]
    cursor?: SignedPrekeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignedPrekeyScalarFieldEnum | SignedPrekeyScalarFieldEnum[]
  }

  /**
   * User.signalIdentities
   */
  export type User$signalIdentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    where?: SignalIdentityWhereInput
    orderBy?: SignalIdentityOrderByWithRelationInput | SignalIdentityOrderByWithRelationInput[]
    cursor?: SignalIdentityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalIdentityScalarFieldEnum | SignalIdentityScalarFieldEnum[]
  }

  /**
   * User.groupMembers
   */
  export type User$groupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.createdGroups
   */
  export type User$createdGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.userContacts
   */
  export type User$userContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.mediaFiles
   */
  export type User$mediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    cursor?: MediaFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.otpAttempts
   */
  export type User$otpAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    where?: OtpAttemptWhereInput
    orderBy?: OtpAttemptOrderByWithRelationInput | OtpAttemptOrderByWithRelationInput[]
    cursor?: OtpAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpAttemptScalarFieldEnum | OtpAttemptScalarFieldEnum[]
  }

  /**
   * User.deletedMessages
   */
  export type User$deletedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    where?: DeletedMessageWhereInput
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    cursor?: DeletedMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeletedMessageScalarFieldEnum | DeletedMessageScalarFieldEnum[]
  }

  /**
   * User.sessionStates
   */
  export type User$sessionStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    where?: SessionStateWhereInput
    orderBy?: SessionStateOrderByWithRelationInput | SessionStateOrderByWithRelationInput[]
    cursor?: SessionStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionStateScalarFieldEnum | SessionStateScalarFieldEnum[]
  }

  /**
   * User.ownedContacts
   */
  export type User$ownedContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    where?: UserContactWhereInput
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    cursor?: UserContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * User.contactedBy
   */
  export type User$contactedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    where?: UserContactWhereInput
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    cursor?: UserContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PrekeyBundle
   */

  export type AggregatePrekeyBundle = {
    _count: PrekeyBundleCountAggregateOutputType | null
    _avg: PrekeyBundleAvgAggregateOutputType | null
    _sum: PrekeyBundleSumAggregateOutputType | null
    _min: PrekeyBundleMinAggregateOutputType | null
    _max: PrekeyBundleMaxAggregateOutputType | null
  }

  export type PrekeyBundleAvgAggregateOutputType = {
    id: number | null
    deviceId: number | null
    keyId: number | null
  }

  export type PrekeyBundleSumAggregateOutputType = {
    id: number | null
    deviceId: number | null
    keyId: number | null
  }

  export type PrekeyBundleMinAggregateOutputType = {
    id: number | null
    userId: string | null
    deviceId: number | null
    keyId: number | null
    publicKey: string | null
    signature: string | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type PrekeyBundleMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    deviceId: number | null
    keyId: number | null
    publicKey: string | null
    signature: string | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type PrekeyBundleCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    keyId: number
    publicKey: number
    signature: number
    isUsed: number
    createdAt: number
    _all: number
  }


  export type PrekeyBundleAvgAggregateInputType = {
    id?: true
    deviceId?: true
    keyId?: true
  }

  export type PrekeyBundleSumAggregateInputType = {
    id?: true
    deviceId?: true
    keyId?: true
  }

  export type PrekeyBundleMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    isUsed?: true
    createdAt?: true
  }

  export type PrekeyBundleMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    isUsed?: true
    createdAt?: true
  }

  export type PrekeyBundleCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    isUsed?: true
    createdAt?: true
    _all?: true
  }

  export type PrekeyBundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrekeyBundle to aggregate.
     */
    where?: PrekeyBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrekeyBundles to fetch.
     */
    orderBy?: PrekeyBundleOrderByWithRelationInput | PrekeyBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrekeyBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrekeyBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrekeyBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrekeyBundles
    **/
    _count?: true | PrekeyBundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrekeyBundleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrekeyBundleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrekeyBundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrekeyBundleMaxAggregateInputType
  }

  export type GetPrekeyBundleAggregateType<T extends PrekeyBundleAggregateArgs> = {
        [P in keyof T & keyof AggregatePrekeyBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrekeyBundle[P]>
      : GetScalarType<T[P], AggregatePrekeyBundle[P]>
  }




  export type PrekeyBundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrekeyBundleWhereInput
    orderBy?: PrekeyBundleOrderByWithAggregationInput | PrekeyBundleOrderByWithAggregationInput[]
    by: PrekeyBundleScalarFieldEnum[] | PrekeyBundleScalarFieldEnum
    having?: PrekeyBundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrekeyBundleCountAggregateInputType | true
    _avg?: PrekeyBundleAvgAggregateInputType
    _sum?: PrekeyBundleSumAggregateInputType
    _min?: PrekeyBundleMinAggregateInputType
    _max?: PrekeyBundleMaxAggregateInputType
  }

  export type PrekeyBundleGroupByOutputType = {
    id: number
    userId: string
    deviceId: number
    keyId: number
    publicKey: string
    signature: string
    isUsed: boolean
    createdAt: Date
    _count: PrekeyBundleCountAggregateOutputType | null
    _avg: PrekeyBundleAvgAggregateOutputType | null
    _sum: PrekeyBundleSumAggregateOutputType | null
    _min: PrekeyBundleMinAggregateOutputType | null
    _max: PrekeyBundleMaxAggregateOutputType | null
  }

  type GetPrekeyBundleGroupByPayload<T extends PrekeyBundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrekeyBundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrekeyBundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrekeyBundleGroupByOutputType[P]>
            : GetScalarType<T[P], PrekeyBundleGroupByOutputType[P]>
        }
      >
    >


  export type PrekeyBundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prekeyBundle"]>

  export type PrekeyBundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prekeyBundle"]>

  export type PrekeyBundleSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }

  export type PrekeyBundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrekeyBundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrekeyBundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrekeyBundle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      deviceId: number
      keyId: number
      publicKey: string
      signature: string
      isUsed: boolean
      createdAt: Date
    }, ExtArgs["result"]["prekeyBundle"]>
    composites: {}
  }

  type PrekeyBundleGetPayload<S extends boolean | null | undefined | PrekeyBundleDefaultArgs> = $Result.GetResult<Prisma.$PrekeyBundlePayload, S>

  type PrekeyBundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrekeyBundleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrekeyBundleCountAggregateInputType | true
    }

  export interface PrekeyBundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrekeyBundle'], meta: { name: 'PrekeyBundle' } }
    /**
     * Find zero or one PrekeyBundle that matches the filter.
     * @param {PrekeyBundleFindUniqueArgs} args - Arguments to find a PrekeyBundle
     * @example
     * // Get one PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrekeyBundleFindUniqueArgs>(args: SelectSubset<T, PrekeyBundleFindUniqueArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrekeyBundle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrekeyBundleFindUniqueOrThrowArgs} args - Arguments to find a PrekeyBundle
     * @example
     * // Get one PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrekeyBundleFindUniqueOrThrowArgs>(args: SelectSubset<T, PrekeyBundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrekeyBundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleFindFirstArgs} args - Arguments to find a PrekeyBundle
     * @example
     * // Get one PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrekeyBundleFindFirstArgs>(args?: SelectSubset<T, PrekeyBundleFindFirstArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrekeyBundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleFindFirstOrThrowArgs} args - Arguments to find a PrekeyBundle
     * @example
     * // Get one PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrekeyBundleFindFirstOrThrowArgs>(args?: SelectSubset<T, PrekeyBundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrekeyBundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrekeyBundles
     * const prekeyBundles = await prisma.prekeyBundle.findMany()
     * 
     * // Get first 10 PrekeyBundles
     * const prekeyBundles = await prisma.prekeyBundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prekeyBundleWithIdOnly = await prisma.prekeyBundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrekeyBundleFindManyArgs>(args?: SelectSubset<T, PrekeyBundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrekeyBundle.
     * @param {PrekeyBundleCreateArgs} args - Arguments to create a PrekeyBundle.
     * @example
     * // Create one PrekeyBundle
     * const PrekeyBundle = await prisma.prekeyBundle.create({
     *   data: {
     *     // ... data to create a PrekeyBundle
     *   }
     * })
     * 
     */
    create<T extends PrekeyBundleCreateArgs>(args: SelectSubset<T, PrekeyBundleCreateArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrekeyBundles.
     * @param {PrekeyBundleCreateManyArgs} args - Arguments to create many PrekeyBundles.
     * @example
     * // Create many PrekeyBundles
     * const prekeyBundle = await prisma.prekeyBundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrekeyBundleCreateManyArgs>(args?: SelectSubset<T, PrekeyBundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrekeyBundles and returns the data saved in the database.
     * @param {PrekeyBundleCreateManyAndReturnArgs} args - Arguments to create many PrekeyBundles.
     * @example
     * // Create many PrekeyBundles
     * const prekeyBundle = await prisma.prekeyBundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrekeyBundles and only return the `id`
     * const prekeyBundleWithIdOnly = await prisma.prekeyBundle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrekeyBundleCreateManyAndReturnArgs>(args?: SelectSubset<T, PrekeyBundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrekeyBundle.
     * @param {PrekeyBundleDeleteArgs} args - Arguments to delete one PrekeyBundle.
     * @example
     * // Delete one PrekeyBundle
     * const PrekeyBundle = await prisma.prekeyBundle.delete({
     *   where: {
     *     // ... filter to delete one PrekeyBundle
     *   }
     * })
     * 
     */
    delete<T extends PrekeyBundleDeleteArgs>(args: SelectSubset<T, PrekeyBundleDeleteArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrekeyBundle.
     * @param {PrekeyBundleUpdateArgs} args - Arguments to update one PrekeyBundle.
     * @example
     * // Update one PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrekeyBundleUpdateArgs>(args: SelectSubset<T, PrekeyBundleUpdateArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrekeyBundles.
     * @param {PrekeyBundleDeleteManyArgs} args - Arguments to filter PrekeyBundles to delete.
     * @example
     * // Delete a few PrekeyBundles
     * const { count } = await prisma.prekeyBundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrekeyBundleDeleteManyArgs>(args?: SelectSubset<T, PrekeyBundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrekeyBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrekeyBundles
     * const prekeyBundle = await prisma.prekeyBundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrekeyBundleUpdateManyArgs>(args: SelectSubset<T, PrekeyBundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrekeyBundle.
     * @param {PrekeyBundleUpsertArgs} args - Arguments to update or create a PrekeyBundle.
     * @example
     * // Update or create a PrekeyBundle
     * const prekeyBundle = await prisma.prekeyBundle.upsert({
     *   create: {
     *     // ... data to create a PrekeyBundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrekeyBundle we want to update
     *   }
     * })
     */
    upsert<T extends PrekeyBundleUpsertArgs>(args: SelectSubset<T, PrekeyBundleUpsertArgs<ExtArgs>>): Prisma__PrekeyBundleClient<$Result.GetResult<Prisma.$PrekeyBundlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrekeyBundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleCountArgs} args - Arguments to filter PrekeyBundles to count.
     * @example
     * // Count the number of PrekeyBundles
     * const count = await prisma.prekeyBundle.count({
     *   where: {
     *     // ... the filter for the PrekeyBundles we want to count
     *   }
     * })
    **/
    count<T extends PrekeyBundleCountArgs>(
      args?: Subset<T, PrekeyBundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrekeyBundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrekeyBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrekeyBundleAggregateArgs>(args: Subset<T, PrekeyBundleAggregateArgs>): Prisma.PrismaPromise<GetPrekeyBundleAggregateType<T>>

    /**
     * Group by PrekeyBundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrekeyBundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrekeyBundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrekeyBundleGroupByArgs['orderBy'] }
        : { orderBy?: PrekeyBundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrekeyBundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrekeyBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrekeyBundle model
   */
  readonly fields: PrekeyBundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrekeyBundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrekeyBundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrekeyBundle model
   */ 
  interface PrekeyBundleFieldRefs {
    readonly id: FieldRef<"PrekeyBundle", 'Int'>
    readonly userId: FieldRef<"PrekeyBundle", 'String'>
    readonly deviceId: FieldRef<"PrekeyBundle", 'Int'>
    readonly keyId: FieldRef<"PrekeyBundle", 'Int'>
    readonly publicKey: FieldRef<"PrekeyBundle", 'String'>
    readonly signature: FieldRef<"PrekeyBundle", 'String'>
    readonly isUsed: FieldRef<"PrekeyBundle", 'Boolean'>
    readonly createdAt: FieldRef<"PrekeyBundle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrekeyBundle findUnique
   */
  export type PrekeyBundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter, which PrekeyBundle to fetch.
     */
    where: PrekeyBundleWhereUniqueInput
  }

  /**
   * PrekeyBundle findUniqueOrThrow
   */
  export type PrekeyBundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter, which PrekeyBundle to fetch.
     */
    where: PrekeyBundleWhereUniqueInput
  }

  /**
   * PrekeyBundle findFirst
   */
  export type PrekeyBundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter, which PrekeyBundle to fetch.
     */
    where?: PrekeyBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrekeyBundles to fetch.
     */
    orderBy?: PrekeyBundleOrderByWithRelationInput | PrekeyBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrekeyBundles.
     */
    cursor?: PrekeyBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrekeyBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrekeyBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrekeyBundles.
     */
    distinct?: PrekeyBundleScalarFieldEnum | PrekeyBundleScalarFieldEnum[]
  }

  /**
   * PrekeyBundle findFirstOrThrow
   */
  export type PrekeyBundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter, which PrekeyBundle to fetch.
     */
    where?: PrekeyBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrekeyBundles to fetch.
     */
    orderBy?: PrekeyBundleOrderByWithRelationInput | PrekeyBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrekeyBundles.
     */
    cursor?: PrekeyBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrekeyBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrekeyBundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrekeyBundles.
     */
    distinct?: PrekeyBundleScalarFieldEnum | PrekeyBundleScalarFieldEnum[]
  }

  /**
   * PrekeyBundle findMany
   */
  export type PrekeyBundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter, which PrekeyBundles to fetch.
     */
    where?: PrekeyBundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrekeyBundles to fetch.
     */
    orderBy?: PrekeyBundleOrderByWithRelationInput | PrekeyBundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrekeyBundles.
     */
    cursor?: PrekeyBundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrekeyBundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrekeyBundles.
     */
    skip?: number
    distinct?: PrekeyBundleScalarFieldEnum | PrekeyBundleScalarFieldEnum[]
  }

  /**
   * PrekeyBundle create
   */
  export type PrekeyBundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * The data needed to create a PrekeyBundle.
     */
    data: XOR<PrekeyBundleCreateInput, PrekeyBundleUncheckedCreateInput>
  }

  /**
   * PrekeyBundle createMany
   */
  export type PrekeyBundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrekeyBundles.
     */
    data: PrekeyBundleCreateManyInput | PrekeyBundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrekeyBundle createManyAndReturn
   */
  export type PrekeyBundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrekeyBundles.
     */
    data: PrekeyBundleCreateManyInput | PrekeyBundleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrekeyBundle update
   */
  export type PrekeyBundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * The data needed to update a PrekeyBundle.
     */
    data: XOR<PrekeyBundleUpdateInput, PrekeyBundleUncheckedUpdateInput>
    /**
     * Choose, which PrekeyBundle to update.
     */
    where: PrekeyBundleWhereUniqueInput
  }

  /**
   * PrekeyBundle updateMany
   */
  export type PrekeyBundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrekeyBundles.
     */
    data: XOR<PrekeyBundleUpdateManyMutationInput, PrekeyBundleUncheckedUpdateManyInput>
    /**
     * Filter which PrekeyBundles to update
     */
    where?: PrekeyBundleWhereInput
  }

  /**
   * PrekeyBundle upsert
   */
  export type PrekeyBundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * The filter to search for the PrekeyBundle to update in case it exists.
     */
    where: PrekeyBundleWhereUniqueInput
    /**
     * In case the PrekeyBundle found by the `where` argument doesn't exist, create a new PrekeyBundle with this data.
     */
    create: XOR<PrekeyBundleCreateInput, PrekeyBundleUncheckedCreateInput>
    /**
     * In case the PrekeyBundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrekeyBundleUpdateInput, PrekeyBundleUncheckedUpdateInput>
  }

  /**
   * PrekeyBundle delete
   */
  export type PrekeyBundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
    /**
     * Filter which PrekeyBundle to delete.
     */
    where: PrekeyBundleWhereUniqueInput
  }

  /**
   * PrekeyBundle deleteMany
   */
  export type PrekeyBundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrekeyBundles to delete
     */
    where?: PrekeyBundleWhereInput
  }

  /**
   * PrekeyBundle without action
   */
  export type PrekeyBundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrekeyBundle
     */
    select?: PrekeyBundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrekeyBundleInclude<ExtArgs> | null
  }


  /**
   * Model SignedPrekey
   */

  export type AggregateSignedPrekey = {
    _count: SignedPrekeyCountAggregateOutputType | null
    _avg: SignedPrekeyAvgAggregateOutputType | null
    _sum: SignedPrekeySumAggregateOutputType | null
    _min: SignedPrekeyMinAggregateOutputType | null
    _max: SignedPrekeyMaxAggregateOutputType | null
  }

  export type SignedPrekeyAvgAggregateOutputType = {
    id: number | null
    deviceId: number | null
    keyId: number | null
  }

  export type SignedPrekeySumAggregateOutputType = {
    id: number | null
    deviceId: number | null
    keyId: number | null
  }

  export type SignedPrekeyMinAggregateOutputType = {
    id: number | null
    userId: string | null
    deviceId: number | null
    keyId: number | null
    publicKey: string | null
    signature: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type SignedPrekeyMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    deviceId: number | null
    keyId: number | null
    publicKey: string | null
    signature: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type SignedPrekeyCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    keyId: number
    publicKey: number
    signature: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type SignedPrekeyAvgAggregateInputType = {
    id?: true
    deviceId?: true
    keyId?: true
  }

  export type SignedPrekeySumAggregateInputType = {
    id?: true
    deviceId?: true
    keyId?: true
  }

  export type SignedPrekeyMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    timestamp?: true
    createdAt?: true
  }

  export type SignedPrekeyMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    timestamp?: true
    createdAt?: true
  }

  export type SignedPrekeyCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    keyId?: true
    publicKey?: true
    signature?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type SignedPrekeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignedPrekey to aggregate.
     */
    where?: SignedPrekeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignedPrekeys to fetch.
     */
    orderBy?: SignedPrekeyOrderByWithRelationInput | SignedPrekeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignedPrekeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignedPrekeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignedPrekeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignedPrekeys
    **/
    _count?: true | SignedPrekeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignedPrekeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignedPrekeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignedPrekeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignedPrekeyMaxAggregateInputType
  }

  export type GetSignedPrekeyAggregateType<T extends SignedPrekeyAggregateArgs> = {
        [P in keyof T & keyof AggregateSignedPrekey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignedPrekey[P]>
      : GetScalarType<T[P], AggregateSignedPrekey[P]>
  }




  export type SignedPrekeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignedPrekeyWhereInput
    orderBy?: SignedPrekeyOrderByWithAggregationInput | SignedPrekeyOrderByWithAggregationInput[]
    by: SignedPrekeyScalarFieldEnum[] | SignedPrekeyScalarFieldEnum
    having?: SignedPrekeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignedPrekeyCountAggregateInputType | true
    _avg?: SignedPrekeyAvgAggregateInputType
    _sum?: SignedPrekeySumAggregateInputType
    _min?: SignedPrekeyMinAggregateInputType
    _max?: SignedPrekeyMaxAggregateInputType
  }

  export type SignedPrekeyGroupByOutputType = {
    id: number
    userId: string
    deviceId: number
    keyId: number
    publicKey: string
    signature: string
    timestamp: Date
    createdAt: Date
    _count: SignedPrekeyCountAggregateOutputType | null
    _avg: SignedPrekeyAvgAggregateOutputType | null
    _sum: SignedPrekeySumAggregateOutputType | null
    _min: SignedPrekeyMinAggregateOutputType | null
    _max: SignedPrekeyMaxAggregateOutputType | null
  }

  type GetSignedPrekeyGroupByPayload<T extends SignedPrekeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignedPrekeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignedPrekeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignedPrekeyGroupByOutputType[P]>
            : GetScalarType<T[P], SignedPrekeyGroupByOutputType[P]>
        }
      >
    >


  export type SignedPrekeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    timestamp?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signedPrekey"]>

  export type SignedPrekeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    timestamp?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signedPrekey"]>

  export type SignedPrekeySelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    keyId?: boolean
    publicKey?: boolean
    signature?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type SignedPrekeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SignedPrekeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SignedPrekeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SignedPrekey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      deviceId: number
      keyId: number
      publicKey: string
      signature: string
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["signedPrekey"]>
    composites: {}
  }

  type SignedPrekeyGetPayload<S extends boolean | null | undefined | SignedPrekeyDefaultArgs> = $Result.GetResult<Prisma.$SignedPrekeyPayload, S>

  type SignedPrekeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignedPrekeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignedPrekeyCountAggregateInputType | true
    }

  export interface SignedPrekeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SignedPrekey'], meta: { name: 'SignedPrekey' } }
    /**
     * Find zero or one SignedPrekey that matches the filter.
     * @param {SignedPrekeyFindUniqueArgs} args - Arguments to find a SignedPrekey
     * @example
     * // Get one SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignedPrekeyFindUniqueArgs>(args: SelectSubset<T, SignedPrekeyFindUniqueArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SignedPrekey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignedPrekeyFindUniqueOrThrowArgs} args - Arguments to find a SignedPrekey
     * @example
     * // Get one SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignedPrekeyFindUniqueOrThrowArgs>(args: SelectSubset<T, SignedPrekeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SignedPrekey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyFindFirstArgs} args - Arguments to find a SignedPrekey
     * @example
     * // Get one SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignedPrekeyFindFirstArgs>(args?: SelectSubset<T, SignedPrekeyFindFirstArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SignedPrekey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyFindFirstOrThrowArgs} args - Arguments to find a SignedPrekey
     * @example
     * // Get one SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignedPrekeyFindFirstOrThrowArgs>(args?: SelectSubset<T, SignedPrekeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SignedPrekeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignedPrekeys
     * const signedPrekeys = await prisma.signedPrekey.findMany()
     * 
     * // Get first 10 SignedPrekeys
     * const signedPrekeys = await prisma.signedPrekey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signedPrekeyWithIdOnly = await prisma.signedPrekey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignedPrekeyFindManyArgs>(args?: SelectSubset<T, SignedPrekeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SignedPrekey.
     * @param {SignedPrekeyCreateArgs} args - Arguments to create a SignedPrekey.
     * @example
     * // Create one SignedPrekey
     * const SignedPrekey = await prisma.signedPrekey.create({
     *   data: {
     *     // ... data to create a SignedPrekey
     *   }
     * })
     * 
     */
    create<T extends SignedPrekeyCreateArgs>(args: SelectSubset<T, SignedPrekeyCreateArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SignedPrekeys.
     * @param {SignedPrekeyCreateManyArgs} args - Arguments to create many SignedPrekeys.
     * @example
     * // Create many SignedPrekeys
     * const signedPrekey = await prisma.signedPrekey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignedPrekeyCreateManyArgs>(args?: SelectSubset<T, SignedPrekeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SignedPrekeys and returns the data saved in the database.
     * @param {SignedPrekeyCreateManyAndReturnArgs} args - Arguments to create many SignedPrekeys.
     * @example
     * // Create many SignedPrekeys
     * const signedPrekey = await prisma.signedPrekey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SignedPrekeys and only return the `id`
     * const signedPrekeyWithIdOnly = await prisma.signedPrekey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignedPrekeyCreateManyAndReturnArgs>(args?: SelectSubset<T, SignedPrekeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SignedPrekey.
     * @param {SignedPrekeyDeleteArgs} args - Arguments to delete one SignedPrekey.
     * @example
     * // Delete one SignedPrekey
     * const SignedPrekey = await prisma.signedPrekey.delete({
     *   where: {
     *     // ... filter to delete one SignedPrekey
     *   }
     * })
     * 
     */
    delete<T extends SignedPrekeyDeleteArgs>(args: SelectSubset<T, SignedPrekeyDeleteArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SignedPrekey.
     * @param {SignedPrekeyUpdateArgs} args - Arguments to update one SignedPrekey.
     * @example
     * // Update one SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignedPrekeyUpdateArgs>(args: SelectSubset<T, SignedPrekeyUpdateArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SignedPrekeys.
     * @param {SignedPrekeyDeleteManyArgs} args - Arguments to filter SignedPrekeys to delete.
     * @example
     * // Delete a few SignedPrekeys
     * const { count } = await prisma.signedPrekey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignedPrekeyDeleteManyArgs>(args?: SelectSubset<T, SignedPrekeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignedPrekeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignedPrekeys
     * const signedPrekey = await prisma.signedPrekey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignedPrekeyUpdateManyArgs>(args: SelectSubset<T, SignedPrekeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SignedPrekey.
     * @param {SignedPrekeyUpsertArgs} args - Arguments to update or create a SignedPrekey.
     * @example
     * // Update or create a SignedPrekey
     * const signedPrekey = await prisma.signedPrekey.upsert({
     *   create: {
     *     // ... data to create a SignedPrekey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignedPrekey we want to update
     *   }
     * })
     */
    upsert<T extends SignedPrekeyUpsertArgs>(args: SelectSubset<T, SignedPrekeyUpsertArgs<ExtArgs>>): Prisma__SignedPrekeyClient<$Result.GetResult<Prisma.$SignedPrekeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SignedPrekeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyCountArgs} args - Arguments to filter SignedPrekeys to count.
     * @example
     * // Count the number of SignedPrekeys
     * const count = await prisma.signedPrekey.count({
     *   where: {
     *     // ... the filter for the SignedPrekeys we want to count
     *   }
     * })
    **/
    count<T extends SignedPrekeyCountArgs>(
      args?: Subset<T, SignedPrekeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignedPrekeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignedPrekey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignedPrekeyAggregateArgs>(args: Subset<T, SignedPrekeyAggregateArgs>): Prisma.PrismaPromise<GetSignedPrekeyAggregateType<T>>

    /**
     * Group by SignedPrekey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignedPrekeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignedPrekeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignedPrekeyGroupByArgs['orderBy'] }
        : { orderBy?: SignedPrekeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignedPrekeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignedPrekeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SignedPrekey model
   */
  readonly fields: SignedPrekeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignedPrekey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignedPrekeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SignedPrekey model
   */ 
  interface SignedPrekeyFieldRefs {
    readonly id: FieldRef<"SignedPrekey", 'Int'>
    readonly userId: FieldRef<"SignedPrekey", 'String'>
    readonly deviceId: FieldRef<"SignedPrekey", 'Int'>
    readonly keyId: FieldRef<"SignedPrekey", 'Int'>
    readonly publicKey: FieldRef<"SignedPrekey", 'String'>
    readonly signature: FieldRef<"SignedPrekey", 'String'>
    readonly timestamp: FieldRef<"SignedPrekey", 'DateTime'>
    readonly createdAt: FieldRef<"SignedPrekey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SignedPrekey findUnique
   */
  export type SignedPrekeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter, which SignedPrekey to fetch.
     */
    where: SignedPrekeyWhereUniqueInput
  }

  /**
   * SignedPrekey findUniqueOrThrow
   */
  export type SignedPrekeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter, which SignedPrekey to fetch.
     */
    where: SignedPrekeyWhereUniqueInput
  }

  /**
   * SignedPrekey findFirst
   */
  export type SignedPrekeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter, which SignedPrekey to fetch.
     */
    where?: SignedPrekeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignedPrekeys to fetch.
     */
    orderBy?: SignedPrekeyOrderByWithRelationInput | SignedPrekeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignedPrekeys.
     */
    cursor?: SignedPrekeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignedPrekeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignedPrekeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignedPrekeys.
     */
    distinct?: SignedPrekeyScalarFieldEnum | SignedPrekeyScalarFieldEnum[]
  }

  /**
   * SignedPrekey findFirstOrThrow
   */
  export type SignedPrekeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter, which SignedPrekey to fetch.
     */
    where?: SignedPrekeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignedPrekeys to fetch.
     */
    orderBy?: SignedPrekeyOrderByWithRelationInput | SignedPrekeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignedPrekeys.
     */
    cursor?: SignedPrekeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignedPrekeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignedPrekeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignedPrekeys.
     */
    distinct?: SignedPrekeyScalarFieldEnum | SignedPrekeyScalarFieldEnum[]
  }

  /**
   * SignedPrekey findMany
   */
  export type SignedPrekeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter, which SignedPrekeys to fetch.
     */
    where?: SignedPrekeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignedPrekeys to fetch.
     */
    orderBy?: SignedPrekeyOrderByWithRelationInput | SignedPrekeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignedPrekeys.
     */
    cursor?: SignedPrekeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignedPrekeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignedPrekeys.
     */
    skip?: number
    distinct?: SignedPrekeyScalarFieldEnum | SignedPrekeyScalarFieldEnum[]
  }

  /**
   * SignedPrekey create
   */
  export type SignedPrekeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * The data needed to create a SignedPrekey.
     */
    data: XOR<SignedPrekeyCreateInput, SignedPrekeyUncheckedCreateInput>
  }

  /**
   * SignedPrekey createMany
   */
  export type SignedPrekeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SignedPrekeys.
     */
    data: SignedPrekeyCreateManyInput | SignedPrekeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignedPrekey createManyAndReturn
   */
  export type SignedPrekeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SignedPrekeys.
     */
    data: SignedPrekeyCreateManyInput | SignedPrekeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SignedPrekey update
   */
  export type SignedPrekeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * The data needed to update a SignedPrekey.
     */
    data: XOR<SignedPrekeyUpdateInput, SignedPrekeyUncheckedUpdateInput>
    /**
     * Choose, which SignedPrekey to update.
     */
    where: SignedPrekeyWhereUniqueInput
  }

  /**
   * SignedPrekey updateMany
   */
  export type SignedPrekeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SignedPrekeys.
     */
    data: XOR<SignedPrekeyUpdateManyMutationInput, SignedPrekeyUncheckedUpdateManyInput>
    /**
     * Filter which SignedPrekeys to update
     */
    where?: SignedPrekeyWhereInput
  }

  /**
   * SignedPrekey upsert
   */
  export type SignedPrekeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * The filter to search for the SignedPrekey to update in case it exists.
     */
    where: SignedPrekeyWhereUniqueInput
    /**
     * In case the SignedPrekey found by the `where` argument doesn't exist, create a new SignedPrekey with this data.
     */
    create: XOR<SignedPrekeyCreateInput, SignedPrekeyUncheckedCreateInput>
    /**
     * In case the SignedPrekey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignedPrekeyUpdateInput, SignedPrekeyUncheckedUpdateInput>
  }

  /**
   * SignedPrekey delete
   */
  export type SignedPrekeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
    /**
     * Filter which SignedPrekey to delete.
     */
    where: SignedPrekeyWhereUniqueInput
  }

  /**
   * SignedPrekey deleteMany
   */
  export type SignedPrekeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignedPrekeys to delete
     */
    where?: SignedPrekeyWhereInput
  }

  /**
   * SignedPrekey without action
   */
  export type SignedPrekeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignedPrekey
     */
    select?: SignedPrekeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignedPrekeyInclude<ExtArgs> | null
  }


  /**
   * Model SessionState
   */

  export type AggregateSessionState = {
    _count: SessionStateCountAggregateOutputType | null
    _min: SessionStateMinAggregateOutputType | null
    _max: SessionStateMaxAggregateOutputType | null
  }

  export type SessionStateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    remoteUserId: string | null
    sessionData: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionStateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    remoteUserId: string | null
    sessionData: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionStateCountAggregateOutputType = {
    id: number
    userId: number
    remoteUserId: number
    sessionData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionStateMinAggregateInputType = {
    id?: true
    userId?: true
    remoteUserId?: true
    sessionData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionStateMaxAggregateInputType = {
    id?: true
    userId?: true
    remoteUserId?: true
    sessionData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionStateCountAggregateInputType = {
    id?: true
    userId?: true
    remoteUserId?: true
    sessionData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionState to aggregate.
     */
    where?: SessionStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStates to fetch.
     */
    orderBy?: SessionStateOrderByWithRelationInput | SessionStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionStates
    **/
    _count?: true | SessionStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionStateMaxAggregateInputType
  }

  export type GetSessionStateAggregateType<T extends SessionStateAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionState[P]>
      : GetScalarType<T[P], AggregateSessionState[P]>
  }




  export type SessionStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionStateWhereInput
    orderBy?: SessionStateOrderByWithAggregationInput | SessionStateOrderByWithAggregationInput[]
    by: SessionStateScalarFieldEnum[] | SessionStateScalarFieldEnum
    having?: SessionStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionStateCountAggregateInputType | true
    _min?: SessionStateMinAggregateInputType
    _max?: SessionStateMaxAggregateInputType
  }

  export type SessionStateGroupByOutputType = {
    id: string
    userId: string
    remoteUserId: string
    sessionData: Buffer
    createdAt: Date
    updatedAt: Date
    _count: SessionStateCountAggregateOutputType | null
    _min: SessionStateMinAggregateOutputType | null
    _max: SessionStateMaxAggregateOutputType | null
  }

  type GetSessionStateGroupByPayload<T extends SessionStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionStateGroupByOutputType[P]>
            : GetScalarType<T[P], SessionStateGroupByOutputType[P]>
        }
      >
    >


  export type SessionStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    remoteUserId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionState"]>

  export type SessionStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    remoteUserId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionState"]>

  export type SessionStateSelectScalar = {
    id?: boolean
    userId?: boolean
    remoteUserId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionState"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      remoteUserId: string
      sessionData: Buffer
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionState"]>
    composites: {}
  }

  type SessionStateGetPayload<S extends boolean | null | undefined | SessionStateDefaultArgs> = $Result.GetResult<Prisma.$SessionStatePayload, S>

  type SessionStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionStateCountAggregateInputType | true
    }

  export interface SessionStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionState'], meta: { name: 'SessionState' } }
    /**
     * Find zero or one SessionState that matches the filter.
     * @param {SessionStateFindUniqueArgs} args - Arguments to find a SessionState
     * @example
     * // Get one SessionState
     * const sessionState = await prisma.sessionState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionStateFindUniqueArgs>(args: SelectSubset<T, SessionStateFindUniqueArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionStateFindUniqueOrThrowArgs} args - Arguments to find a SessionState
     * @example
     * // Get one SessionState
     * const sessionState = await prisma.sessionState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionStateFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateFindFirstArgs} args - Arguments to find a SessionState
     * @example
     * // Get one SessionState
     * const sessionState = await prisma.sessionState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionStateFindFirstArgs>(args?: SelectSubset<T, SessionStateFindFirstArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateFindFirstOrThrowArgs} args - Arguments to find a SessionState
     * @example
     * // Get one SessionState
     * const sessionState = await prisma.sessionState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionStateFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionStates
     * const sessionStates = await prisma.sessionState.findMany()
     * 
     * // Get first 10 SessionStates
     * const sessionStates = await prisma.sessionState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionStateWithIdOnly = await prisma.sessionState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionStateFindManyArgs>(args?: SelectSubset<T, SessionStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionState.
     * @param {SessionStateCreateArgs} args - Arguments to create a SessionState.
     * @example
     * // Create one SessionState
     * const SessionState = await prisma.sessionState.create({
     *   data: {
     *     // ... data to create a SessionState
     *   }
     * })
     * 
     */
    create<T extends SessionStateCreateArgs>(args: SelectSubset<T, SessionStateCreateArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionStates.
     * @param {SessionStateCreateManyArgs} args - Arguments to create many SessionStates.
     * @example
     * // Create many SessionStates
     * const sessionState = await prisma.sessionState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionStateCreateManyArgs>(args?: SelectSubset<T, SessionStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionStates and returns the data saved in the database.
     * @param {SessionStateCreateManyAndReturnArgs} args - Arguments to create many SessionStates.
     * @example
     * // Create many SessionStates
     * const sessionState = await prisma.sessionState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionStates and only return the `id`
     * const sessionStateWithIdOnly = await prisma.sessionState.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionStateCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionState.
     * @param {SessionStateDeleteArgs} args - Arguments to delete one SessionState.
     * @example
     * // Delete one SessionState
     * const SessionState = await prisma.sessionState.delete({
     *   where: {
     *     // ... filter to delete one SessionState
     *   }
     * })
     * 
     */
    delete<T extends SessionStateDeleteArgs>(args: SelectSubset<T, SessionStateDeleteArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionState.
     * @param {SessionStateUpdateArgs} args - Arguments to update one SessionState.
     * @example
     * // Update one SessionState
     * const sessionState = await prisma.sessionState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionStateUpdateArgs>(args: SelectSubset<T, SessionStateUpdateArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionStates.
     * @param {SessionStateDeleteManyArgs} args - Arguments to filter SessionStates to delete.
     * @example
     * // Delete a few SessionStates
     * const { count } = await prisma.sessionState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionStateDeleteManyArgs>(args?: SelectSubset<T, SessionStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionStates
     * const sessionState = await prisma.sessionState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionStateUpdateManyArgs>(args: SelectSubset<T, SessionStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionState.
     * @param {SessionStateUpsertArgs} args - Arguments to update or create a SessionState.
     * @example
     * // Update or create a SessionState
     * const sessionState = await prisma.sessionState.upsert({
     *   create: {
     *     // ... data to create a SessionState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionState we want to update
     *   }
     * })
     */
    upsert<T extends SessionStateUpsertArgs>(args: SelectSubset<T, SessionStateUpsertArgs<ExtArgs>>): Prisma__SessionStateClient<$Result.GetResult<Prisma.$SessionStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateCountArgs} args - Arguments to filter SessionStates to count.
     * @example
     * // Count the number of SessionStates
     * const count = await prisma.sessionState.count({
     *   where: {
     *     // ... the filter for the SessionStates we want to count
     *   }
     * })
    **/
    count<T extends SessionStateCountArgs>(
      args?: Subset<T, SessionStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionStateAggregateArgs>(args: Subset<T, SessionStateAggregateArgs>): Prisma.PrismaPromise<GetSessionStateAggregateType<T>>

    /**
     * Group by SessionState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionStateGroupByArgs['orderBy'] }
        : { orderBy?: SessionStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionState model
   */
  readonly fields: SessionStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionState model
   */ 
  interface SessionStateFieldRefs {
    readonly id: FieldRef<"SessionState", 'String'>
    readonly userId: FieldRef<"SessionState", 'String'>
    readonly remoteUserId: FieldRef<"SessionState", 'String'>
    readonly sessionData: FieldRef<"SessionState", 'Bytes'>
    readonly createdAt: FieldRef<"SessionState", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionState findUnique
   */
  export type SessionStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter, which SessionState to fetch.
     */
    where: SessionStateWhereUniqueInput
  }

  /**
   * SessionState findUniqueOrThrow
   */
  export type SessionStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter, which SessionState to fetch.
     */
    where: SessionStateWhereUniqueInput
  }

  /**
   * SessionState findFirst
   */
  export type SessionStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter, which SessionState to fetch.
     */
    where?: SessionStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStates to fetch.
     */
    orderBy?: SessionStateOrderByWithRelationInput | SessionStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionStates.
     */
    cursor?: SessionStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionStates.
     */
    distinct?: SessionStateScalarFieldEnum | SessionStateScalarFieldEnum[]
  }

  /**
   * SessionState findFirstOrThrow
   */
  export type SessionStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter, which SessionState to fetch.
     */
    where?: SessionStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStates to fetch.
     */
    orderBy?: SessionStateOrderByWithRelationInput | SessionStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionStates.
     */
    cursor?: SessionStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionStates.
     */
    distinct?: SessionStateScalarFieldEnum | SessionStateScalarFieldEnum[]
  }

  /**
   * SessionState findMany
   */
  export type SessionStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter, which SessionStates to fetch.
     */
    where?: SessionStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStates to fetch.
     */
    orderBy?: SessionStateOrderByWithRelationInput | SessionStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionStates.
     */
    cursor?: SessionStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStates.
     */
    skip?: number
    distinct?: SessionStateScalarFieldEnum | SessionStateScalarFieldEnum[]
  }

  /**
   * SessionState create
   */
  export type SessionStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionState.
     */
    data: XOR<SessionStateCreateInput, SessionStateUncheckedCreateInput>
  }

  /**
   * SessionState createMany
   */
  export type SessionStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionStates.
     */
    data: SessionStateCreateManyInput | SessionStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionState createManyAndReturn
   */
  export type SessionStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionStates.
     */
    data: SessionStateCreateManyInput | SessionStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionState update
   */
  export type SessionStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionState.
     */
    data: XOR<SessionStateUpdateInput, SessionStateUncheckedUpdateInput>
    /**
     * Choose, which SessionState to update.
     */
    where: SessionStateWhereUniqueInput
  }

  /**
   * SessionState updateMany
   */
  export type SessionStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionStates.
     */
    data: XOR<SessionStateUpdateManyMutationInput, SessionStateUncheckedUpdateManyInput>
    /**
     * Filter which SessionStates to update
     */
    where?: SessionStateWhereInput
  }

  /**
   * SessionState upsert
   */
  export type SessionStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionState to update in case it exists.
     */
    where: SessionStateWhereUniqueInput
    /**
     * In case the SessionState found by the `where` argument doesn't exist, create a new SessionState with this data.
     */
    create: XOR<SessionStateCreateInput, SessionStateUncheckedCreateInput>
    /**
     * In case the SessionState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionStateUpdateInput, SessionStateUncheckedUpdateInput>
  }

  /**
   * SessionState delete
   */
  export type SessionStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
    /**
     * Filter which SessionState to delete.
     */
    where: SessionStateWhereUniqueInput
  }

  /**
   * SessionState deleteMany
   */
  export type SessionStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionStates to delete
     */
    where?: SessionStateWhereInput
  }

  /**
   * SessionState without action
   */
  export type SessionStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionState
     */
    select?: SessionStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStateInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type MessageSumAggregateOutputType = {
    timestamp: bigint | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    groupId: string | null
    encryptedContent: Buffer | null
    messageType: $Enums.MessageType | null
    timestamp: bigint | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    status: $Enums.MessageStatus | null
    isDeleted: boolean | null
    deletedAt: Date | null
    replyToId: string | null
    isForwarded: boolean | null
    mediaFileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    groupId: string | null
    encryptedContent: Buffer | null
    messageType: $Enums.MessageType | null
    timestamp: bigint | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    status: $Enums.MessageStatus | null
    isDeleted: boolean | null
    deletedAt: Date | null
    replyToId: string | null
    isForwarded: boolean | null
    mediaFileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    recipientId: number
    groupId: number
    encryptedContent: number
    messageType: number
    timestamp: number
    sentAt: number
    deliveredAt: number
    readAt: number
    status: number
    isDeleted: number
    deletedAt: number
    replyToId: number
    isForwarded: number
    mediaFileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    timestamp?: true
  }

  export type MessageSumAggregateInputType = {
    timestamp?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    groupId?: true
    encryptedContent?: true
    messageType?: true
    timestamp?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    replyToId?: true
    isForwarded?: true
    mediaFileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    groupId?: true
    encryptedContent?: true
    messageType?: true
    timestamp?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    replyToId?: true
    isForwarded?: true
    mediaFileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    groupId?: true
    encryptedContent?: true
    messageType?: true
    timestamp?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    replyToId?: true
    isForwarded?: true
    mediaFileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    recipientId: string | null
    groupId: string | null
    encryptedContent: Buffer
    messageType: $Enums.MessageType
    timestamp: bigint
    sentAt: Date
    deliveredAt: Date | null
    readAt: Date | null
    status: $Enums.MessageStatus
    isDeleted: boolean
    deletedAt: Date | null
    replyToId: string | null
    isForwarded: boolean
    mediaFileId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    groupId?: boolean
    encryptedContent?: boolean
    messageType?: boolean
    timestamp?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    replyToId?: boolean
    isForwarded?: boolean
    mediaFileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | Message$recipientArgs<ExtArgs>
    group?: boolean | Message$groupArgs<ExtArgs>
    replyTo?: boolean | Message$replyToArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    mediaFile?: boolean | Message$mediaFileArgs<ExtArgs>
    signalMetadata?: boolean | Message$signalMetadataArgs<ExtArgs>
    deletedMessages?: boolean | Message$deletedMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    groupId?: boolean
    encryptedContent?: boolean
    messageType?: boolean
    timestamp?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    replyToId?: boolean
    isForwarded?: boolean
    mediaFileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | Message$recipientArgs<ExtArgs>
    group?: boolean | Message$groupArgs<ExtArgs>
    replyTo?: boolean | Message$replyToArgs<ExtArgs>
    mediaFile?: boolean | Message$mediaFileArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    groupId?: boolean
    encryptedContent?: boolean
    messageType?: boolean
    timestamp?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    replyToId?: boolean
    isForwarded?: boolean
    mediaFileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | Message$recipientArgs<ExtArgs>
    group?: boolean | Message$groupArgs<ExtArgs>
    replyTo?: boolean | Message$replyToArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    mediaFile?: boolean | Message$mediaFileArgs<ExtArgs>
    signalMetadata?: boolean | Message$signalMetadataArgs<ExtArgs>
    deletedMessages?: boolean | Message$deletedMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | Message$recipientArgs<ExtArgs>
    group?: boolean | Message$groupArgs<ExtArgs>
    replyTo?: boolean | Message$replyToArgs<ExtArgs>
    mediaFile?: boolean | Message$mediaFileArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs> | null
      group: Prisma.$GroupPayload<ExtArgs> | null
      replyTo: Prisma.$MessagePayload<ExtArgs> | null
      replies: Prisma.$MessagePayload<ExtArgs>[]
      mediaFile: Prisma.$MediaFilePayload<ExtArgs> | null
      signalMetadata: Prisma.$SignalMessageMetadataPayload<ExtArgs> | null
      deletedMessages: Prisma.$DeletedMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      recipientId: string | null
      groupId: string | null
      encryptedContent: Buffer
      messageType: $Enums.MessageType
      timestamp: bigint
      sentAt: Date
      deliveredAt: Date | null
      readAt: Date | null
      status: $Enums.MessageStatus
      isDeleted: boolean
      deletedAt: Date | null
      replyToId: string | null
      isForwarded: boolean
      mediaFileId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipient<T extends Message$recipientArgs<ExtArgs> = {}>(args?: Subset<T, Message$recipientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    group<T extends Message$groupArgs<ExtArgs> = {}>(args?: Subset<T, Message$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replyTo<T extends Message$replyToArgs<ExtArgs> = {}>(args?: Subset<T, Message$replyToArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Message$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    mediaFile<T extends Message$mediaFileArgs<ExtArgs> = {}>(args?: Subset<T, Message$mediaFileArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    signalMetadata<T extends Message$signalMetadataArgs<ExtArgs> = {}>(args?: Subset<T, Message$signalMetadataArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deletedMessages<T extends Message$deletedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Message$deletedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
    readonly groupId: FieldRef<"Message", 'String'>
    readonly encryptedContent: FieldRef<"Message", 'Bytes'>
    readonly messageType: FieldRef<"Message", 'MessageType'>
    readonly timestamp: FieldRef<"Message", 'BigInt'>
    readonly sentAt: FieldRef<"Message", 'DateTime'>
    readonly deliveredAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly isDeleted: FieldRef<"Message", 'Boolean'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
    readonly replyToId: FieldRef<"Message", 'String'>
    readonly isForwarded: FieldRef<"Message", 'Boolean'>
    readonly mediaFileId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.recipient
   */
  export type Message$recipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.group
   */
  export type Message$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * Message.replyTo
   */
  export type Message$replyToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replies
   */
  export type Message$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message.mediaFile
   */
  export type Message$mediaFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
  }

  /**
   * Message.signalMetadata
   */
  export type Message$signalMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    where?: SignalMessageMetadataWhereInput
  }

  /**
   * Message.deletedMessages
   */
  export type Message$deletedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    where?: DeletedMessageWhereInput
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    cursor?: DeletedMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeletedMessageScalarFieldEnum | DeletedMessageScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    maxMembers: number | null
  }

  export type GroupSumAggregateOutputType = {
    maxMembers: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    avatarUrl: string | null
    creatorId: string | null
    senderKeyDistribution: Buffer | null
    isPublic: boolean | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    avatarUrl: string | null
    creatorId: string | null
    senderKeyDistribution: Buffer | null
    isPublic: boolean | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    avatarUrl: number
    creatorId: number
    senderKeyDistribution: number
    isPublic: number
    maxMembers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    maxMembers?: true
  }

  export type GroupSumAggregateInputType = {
    maxMembers?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    creatorId?: true
    senderKeyDistribution?: true
    isPublic?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    creatorId?: true
    senderKeyDistribution?: true
    isPublic?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    creatorId?: true
    senderKeyDistribution?: true
    isPublic?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    avatarUrl: string | null
    creatorId: string
    senderKeyDistribution: Buffer | null
    isPublic: boolean
    maxMembers: number
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    creatorId?: boolean
    senderKeyDistribution?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    creatorId?: boolean
    senderKeyDistribution?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    creatorId?: boolean
    senderKeyDistribution?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      avatarUrl: string | null
      creatorId: string
      senderKeyDistribution: Buffer | null
      isPublic: boolean
      maxMembers: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Group$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Group$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly avatarUrl: FieldRef<"Group", 'String'>
    readonly creatorId: FieldRef<"Group", 'String'>
    readonly senderKeyDistribution: FieldRef<"Group", 'Bytes'>
    readonly isPublic: FieldRef<"Group", 'Boolean'>
    readonly maxMembers: FieldRef<"Group", 'Int'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.messages
   */
  export type Group$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupMemberRole | null
    joinedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupMemberRole | null
    joinedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: $Enums.GroupMemberRole
    joinedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: $Enums.GroupMemberRole
      joinedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */ 
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly role: FieldRef<"GroupMember", 'GroupMemberRole'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model UserContact
   */

  export type AggregateUserContact = {
    _count: UserContactCountAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  export type UserContactMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    contactId: string | null
    name: string | null
    isBlocked: boolean | null
    createdAt: Date | null
  }

  export type UserContactMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    contactId: string | null
    name: string | null
    isBlocked: boolean | null
    createdAt: Date | null
  }

  export type UserContactCountAggregateOutputType = {
    id: number
    ownerId: number
    contactId: number
    name: number
    isBlocked: number
    createdAt: number
    _all: number
  }


  export type UserContactMinAggregateInputType = {
    id?: true
    ownerId?: true
    contactId?: true
    name?: true
    isBlocked?: true
    createdAt?: true
  }

  export type UserContactMaxAggregateInputType = {
    id?: true
    ownerId?: true
    contactId?: true
    name?: true
    isBlocked?: true
    createdAt?: true
  }

  export type UserContactCountAggregateInputType = {
    id?: true
    ownerId?: true
    contactId?: true
    name?: true
    isBlocked?: true
    createdAt?: true
    _all?: true
  }

  export type UserContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContact to aggregate.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserContacts
    **/
    _count?: true | UserContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactMaxAggregateInputType
  }

  export type GetUserContactAggregateType<T extends UserContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContact[P]>
      : GetScalarType<T[P], AggregateUserContact[P]>
  }




  export type UserContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
    orderBy?: UserContactOrderByWithAggregationInput | UserContactOrderByWithAggregationInput[]
    by: UserContactScalarFieldEnum[] | UserContactScalarFieldEnum
    having?: UserContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactCountAggregateInputType | true
    _min?: UserContactMinAggregateInputType
    _max?: UserContactMaxAggregateInputType
  }

  export type UserContactGroupByOutputType = {
    id: string
    ownerId: string
    contactId: string
    name: string | null
    isBlocked: boolean
    createdAt: Date
    _count: UserContactCountAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  type GetUserContactGroupByPayload<T extends UserContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserContactGroupByOutputType[P]>
            : GetScalarType<T[P], UserContactGroupByOutputType[P]>
        }
      >
    >


  export type UserContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    contactId?: boolean
    name?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userContact"]>

  export type UserContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    contactId?: boolean
    name?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userContact"]>

  export type UserContactSelectScalar = {
    id?: boolean
    ownerId?: boolean
    contactId?: boolean
    name?: boolean
    isBlocked?: boolean
    createdAt?: boolean
  }

  export type UserContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserContact"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      contactId: string
      name: string | null
      isBlocked: boolean
      createdAt: Date
    }, ExtArgs["result"]["userContact"]>
    composites: {}
  }

  type UserContactGetPayload<S extends boolean | null | undefined | UserContactDefaultArgs> = $Result.GetResult<Prisma.$UserContactPayload, S>

  type UserContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserContactCountAggregateInputType | true
    }

  export interface UserContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserContact'], meta: { name: 'UserContact' } }
    /**
     * Find zero or one UserContact that matches the filter.
     * @param {UserContactFindUniqueArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserContactFindUniqueArgs>(args: SelectSubset<T, UserContactFindUniqueArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserContactFindUniqueOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserContactFindUniqueOrThrowArgs>(args: SelectSubset<T, UserContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserContactFindFirstArgs>(args?: SelectSubset<T, UserContactFindFirstArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserContactFindFirstOrThrowArgs>(args?: SelectSubset<T, UserContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContacts
     * const userContacts = await prisma.userContact.findMany()
     * 
     * // Get first 10 UserContacts
     * const userContacts = await prisma.userContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userContactWithIdOnly = await prisma.userContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserContactFindManyArgs>(args?: SelectSubset<T, UserContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserContact.
     * @param {UserContactCreateArgs} args - Arguments to create a UserContact.
     * @example
     * // Create one UserContact
     * const UserContact = await prisma.userContact.create({
     *   data: {
     *     // ... data to create a UserContact
     *   }
     * })
     * 
     */
    create<T extends UserContactCreateArgs>(args: SelectSubset<T, UserContactCreateArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserContacts.
     * @param {UserContactCreateManyArgs} args - Arguments to create many UserContacts.
     * @example
     * // Create many UserContacts
     * const userContact = await prisma.userContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserContactCreateManyArgs>(args?: SelectSubset<T, UserContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserContacts and returns the data saved in the database.
     * @param {UserContactCreateManyAndReturnArgs} args - Arguments to create many UserContacts.
     * @example
     * // Create many UserContacts
     * const userContact = await prisma.userContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserContacts and only return the `id`
     * const userContactWithIdOnly = await prisma.userContact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserContactCreateManyAndReturnArgs>(args?: SelectSubset<T, UserContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserContact.
     * @param {UserContactDeleteArgs} args - Arguments to delete one UserContact.
     * @example
     * // Delete one UserContact
     * const UserContact = await prisma.userContact.delete({
     *   where: {
     *     // ... filter to delete one UserContact
     *   }
     * })
     * 
     */
    delete<T extends UserContactDeleteArgs>(args: SelectSubset<T, UserContactDeleteArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserContact.
     * @param {UserContactUpdateArgs} args - Arguments to update one UserContact.
     * @example
     * // Update one UserContact
     * const userContact = await prisma.userContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserContactUpdateArgs>(args: SelectSubset<T, UserContactUpdateArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserContacts.
     * @param {UserContactDeleteManyArgs} args - Arguments to filter UserContacts to delete.
     * @example
     * // Delete a few UserContacts
     * const { count } = await prisma.userContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserContactDeleteManyArgs>(args?: SelectSubset<T, UserContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContacts
     * const userContact = await prisma.userContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserContactUpdateManyArgs>(args: SelectSubset<T, UserContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContact.
     * @param {UserContactUpsertArgs} args - Arguments to update or create a UserContact.
     * @example
     * // Update or create a UserContact
     * const userContact = await prisma.userContact.upsert({
     *   create: {
     *     // ... data to create a UserContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContact we want to update
     *   }
     * })
     */
    upsert<T extends UserContactUpsertArgs>(args: SelectSubset<T, UserContactUpsertArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactCountArgs} args - Arguments to filter UserContacts to count.
     * @example
     * // Count the number of UserContacts
     * const count = await prisma.userContact.count({
     *   where: {
     *     // ... the filter for the UserContacts we want to count
     *   }
     * })
    **/
    count<T extends UserContactCountArgs>(
      args?: Subset<T, UserContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactAggregateArgs>(args: Subset<T, UserContactAggregateArgs>): Prisma.PrismaPromise<GetUserContactAggregateType<T>>

    /**
     * Group by UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactGroupByArgs['orderBy'] }
        : { orderBy?: UserContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserContact model
   */
  readonly fields: UserContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserContact model
   */ 
  interface UserContactFieldRefs {
    readonly id: FieldRef<"UserContact", 'String'>
    readonly ownerId: FieldRef<"UserContact", 'String'>
    readonly contactId: FieldRef<"UserContact", 'String'>
    readonly name: FieldRef<"UserContact", 'String'>
    readonly isBlocked: FieldRef<"UserContact", 'Boolean'>
    readonly createdAt: FieldRef<"UserContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserContact findUnique
   */
  export type UserContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact findUniqueOrThrow
   */
  export type UserContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact findFirst
   */
  export type UserContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact findFirstOrThrow
   */
  export type UserContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact findMany
   */
  export type UserContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContacts to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact create
   */
  export type UserContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to create a UserContact.
     */
    data: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
  }

  /**
   * UserContact createMany
   */
  export type UserContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserContacts.
     */
    data: UserContactCreateManyInput | UserContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserContact createManyAndReturn
   */
  export type UserContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserContacts.
     */
    data: UserContactCreateManyInput | UserContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserContact update
   */
  export type UserContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to update a UserContact.
     */
    data: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
    /**
     * Choose, which UserContact to update.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact updateMany
   */
  export type UserContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserContacts.
     */
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyInput>
    /**
     * Filter which UserContacts to update
     */
    where?: UserContactWhereInput
  }

  /**
   * UserContact upsert
   */
  export type UserContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The filter to search for the UserContact to update in case it exists.
     */
    where: UserContactWhereUniqueInput
    /**
     * In case the UserContact found by the `where` argument doesn't exist, create a new UserContact with this data.
     */
    create: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
    /**
     * In case the UserContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
  }

  /**
   * UserContact delete
   */
  export type UserContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter which UserContact to delete.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact deleteMany
   */
  export type UserContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContacts to delete
     */
    where?: UserContactWhereInput
  }

  /**
   * UserContact without action
   */
  export type UserContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
  }


  /**
   * Model MediaFile
   */

  export type AggregateMediaFile = {
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  export type MediaFileAvgAggregateOutputType = {
    size: number | null
  }

  export type MediaFileSumAggregateOutputType = {
    size: bigint | null
  }

  export type MediaFileMinAggregateOutputType = {
    id: string | null
    uploaderId: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: bigint | null
    mediaType: $Enums.MediaType | null
    isUploaded: boolean | null
    uploadedAt: Date | null
    encryptionKey: string | null
    s3Key: string | null
    s3Bucket: string | null
    thumbnailUrl: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type MediaFileMaxAggregateOutputType = {
    id: string | null
    uploaderId: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: bigint | null
    mediaType: $Enums.MediaType | null
    isUploaded: boolean | null
    uploadedAt: Date | null
    encryptionKey: string | null
    s3Key: string | null
    s3Bucket: string | null
    thumbnailUrl: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type MediaFileCountAggregateOutputType = {
    id: number
    uploaderId: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    mediaType: number
    isUploaded: number
    uploadedAt: number
    encryptionKey: number
    s3Key: number
    s3Bucket: number
    thumbnailUrl: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type MediaFileAvgAggregateInputType = {
    size?: true
  }

  export type MediaFileSumAggregateInputType = {
    size?: true
  }

  export type MediaFileMinAggregateInputType = {
    id?: true
    uploaderId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    mediaType?: true
    isUploaded?: true
    uploadedAt?: true
    encryptionKey?: true
    s3Key?: true
    s3Bucket?: true
    thumbnailUrl?: true
    createdAt?: true
    expiresAt?: true
  }

  export type MediaFileMaxAggregateInputType = {
    id?: true
    uploaderId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    mediaType?: true
    isUploaded?: true
    uploadedAt?: true
    encryptionKey?: true
    s3Key?: true
    s3Bucket?: true
    thumbnailUrl?: true
    createdAt?: true
    expiresAt?: true
  }

  export type MediaFileCountAggregateInputType = {
    id?: true
    uploaderId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    mediaType?: true
    isUploaded?: true
    uploadedAt?: true
    encryptionKey?: true
    s3Key?: true
    s3Bucket?: true
    thumbnailUrl?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type MediaFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFile to aggregate.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaFiles
    **/
    _count?: true | MediaFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaFileMaxAggregateInputType
  }

  export type GetMediaFileAggregateType<T extends MediaFileAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaFile[P]>
      : GetScalarType<T[P], AggregateMediaFile[P]>
  }




  export type MediaFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithAggregationInput | MediaFileOrderByWithAggregationInput[]
    by: MediaFileScalarFieldEnum[] | MediaFileScalarFieldEnum
    having?: MediaFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaFileCountAggregateInputType | true
    _avg?: MediaFileAvgAggregateInputType
    _sum?: MediaFileSumAggregateInputType
    _min?: MediaFileMinAggregateInputType
    _max?: MediaFileMaxAggregateInputType
  }

  export type MediaFileGroupByOutputType = {
    id: string
    uploaderId: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint
    mediaType: $Enums.MediaType | null
    isUploaded: boolean
    uploadedAt: Date | null
    encryptionKey: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl: string | null
    createdAt: Date
    expiresAt: Date | null
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  type GetMediaFileGroupByPayload<T extends MediaFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
            : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
        }
      >
    >


  export type MediaFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploaderId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    isUploaded?: boolean
    uploadedAt?: boolean
    encryptionKey?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | MediaFile$messagesArgs<ExtArgs>
    _count?: boolean | MediaFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploaderId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    isUploaded?: boolean
    uploadedAt?: boolean
    encryptionKey?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectScalar = {
    id?: boolean
    uploaderId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    isUploaded?: boolean
    uploadedAt?: boolean
    encryptionKey?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type MediaFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | MediaFile$messagesArgs<ExtArgs>
    _count?: boolean | MediaFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MediaFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaFile"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploaderId: string
      filename: string
      originalName: string
      mimeType: string
      size: bigint
      mediaType: $Enums.MediaType | null
      isUploaded: boolean
      uploadedAt: Date | null
      encryptionKey: string | null
      s3Key: string
      s3Bucket: string
      thumbnailUrl: string | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["mediaFile"]>
    composites: {}
  }

  type MediaFileGetPayload<S extends boolean | null | undefined | MediaFileDefaultArgs> = $Result.GetResult<Prisma.$MediaFilePayload, S>

  type MediaFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaFileCountAggregateInputType | true
    }

  export interface MediaFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaFile'], meta: { name: 'MediaFile' } }
    /**
     * Find zero or one MediaFile that matches the filter.
     * @param {MediaFileFindUniqueArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFileFindUniqueArgs>(args: SelectSubset<T, MediaFileFindUniqueArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFileFindUniqueOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFileFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFileFindFirstArgs>(args?: SelectSubset<T, MediaFileFindFirstArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFileFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany()
     * 
     * // Get first 10 MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFileFindManyArgs>(args?: SelectSubset<T, MediaFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaFile.
     * @param {MediaFileCreateArgs} args - Arguments to create a MediaFile.
     * @example
     * // Create one MediaFile
     * const MediaFile = await prisma.mediaFile.create({
     *   data: {
     *     // ... data to create a MediaFile
     *   }
     * })
     * 
     */
    create<T extends MediaFileCreateArgs>(args: SelectSubset<T, MediaFileCreateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaFiles.
     * @param {MediaFileCreateManyArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaFileCreateManyArgs>(args?: SelectSubset<T, MediaFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaFiles and returns the data saved in the database.
     * @param {MediaFileCreateManyAndReturnArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaFileCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaFile.
     * @param {MediaFileDeleteArgs} args - Arguments to delete one MediaFile.
     * @example
     * // Delete one MediaFile
     * const MediaFile = await prisma.mediaFile.delete({
     *   where: {
     *     // ... filter to delete one MediaFile
     *   }
     * })
     * 
     */
    delete<T extends MediaFileDeleteArgs>(args: SelectSubset<T, MediaFileDeleteArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaFile.
     * @param {MediaFileUpdateArgs} args - Arguments to update one MediaFile.
     * @example
     * // Update one MediaFile
     * const mediaFile = await prisma.mediaFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaFileUpdateArgs>(args: SelectSubset<T, MediaFileUpdateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaFiles.
     * @param {MediaFileDeleteManyArgs} args - Arguments to filter MediaFiles to delete.
     * @example
     * // Delete a few MediaFiles
     * const { count } = await prisma.mediaFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaFileDeleteManyArgs>(args?: SelectSubset<T, MediaFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaFileUpdateManyArgs>(args: SelectSubset<T, MediaFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaFile.
     * @param {MediaFileUpsertArgs} args - Arguments to update or create a MediaFile.
     * @example
     * // Update or create a MediaFile
     * const mediaFile = await prisma.mediaFile.upsert({
     *   create: {
     *     // ... data to create a MediaFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaFile we want to update
     *   }
     * })
     */
    upsert<T extends MediaFileUpsertArgs>(args: SelectSubset<T, MediaFileUpsertArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileCountArgs} args - Arguments to filter MediaFiles to count.
     * @example
     * // Count the number of MediaFiles
     * const count = await prisma.mediaFile.count({
     *   where: {
     *     // ... the filter for the MediaFiles we want to count
     *   }
     * })
    **/
    count<T extends MediaFileCountArgs>(
      args?: Subset<T, MediaFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaFileAggregateArgs>(args: Subset<T, MediaFileAggregateArgs>): Prisma.PrismaPromise<GetMediaFileAggregateType<T>>

    /**
     * Group by MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaFileGroupByArgs['orderBy'] }
        : { orderBy?: MediaFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaFile model
   */
  readonly fields: MediaFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends MediaFile$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MediaFile$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaFile model
   */ 
  interface MediaFileFieldRefs {
    readonly id: FieldRef<"MediaFile", 'String'>
    readonly uploaderId: FieldRef<"MediaFile", 'String'>
    readonly filename: FieldRef<"MediaFile", 'String'>
    readonly originalName: FieldRef<"MediaFile", 'String'>
    readonly mimeType: FieldRef<"MediaFile", 'String'>
    readonly size: FieldRef<"MediaFile", 'BigInt'>
    readonly mediaType: FieldRef<"MediaFile", 'MediaType'>
    readonly isUploaded: FieldRef<"MediaFile", 'Boolean'>
    readonly uploadedAt: FieldRef<"MediaFile", 'DateTime'>
    readonly encryptionKey: FieldRef<"MediaFile", 'String'>
    readonly s3Key: FieldRef<"MediaFile", 'String'>
    readonly s3Bucket: FieldRef<"MediaFile", 'String'>
    readonly thumbnailUrl: FieldRef<"MediaFile", 'String'>
    readonly createdAt: FieldRef<"MediaFile", 'DateTime'>
    readonly expiresAt: FieldRef<"MediaFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaFile findUnique
   */
  export type MediaFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findUniqueOrThrow
   */
  export type MediaFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findFirst
   */
  export type MediaFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findFirstOrThrow
   */
  export type MediaFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findMany
   */
  export type MediaFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFiles to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile create
   */
  export type MediaFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaFile.
     */
    data: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
  }

  /**
   * MediaFile createMany
   */
  export type MediaFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaFile createManyAndReturn
   */
  export type MediaFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile update
   */
  export type MediaFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaFile.
     */
    data: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
    /**
     * Choose, which MediaFile to update.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile updateMany
   */
  export type MediaFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
  }

  /**
   * MediaFile upsert
   */
  export type MediaFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaFile to update in case it exists.
     */
    where: MediaFileWhereUniqueInput
    /**
     * In case the MediaFile found by the `where` argument doesn't exist, create a new MediaFile with this data.
     */
    create: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
    /**
     * In case the MediaFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
  }

  /**
   * MediaFile delete
   */
  export type MediaFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter which MediaFile to delete.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile deleteMany
   */
  export type MediaFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFiles to delete
     */
    where?: MediaFileWhereInput
  }

  /**
   * MediaFile.messages
   */
  export type MediaFile$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * MediaFile without action
   */
  export type MediaFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isRevoked: boolean | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isRevoked: boolean | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    isRevoked: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    isRevoked?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    isRevoked?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    isRevoked?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    isRevoked: boolean
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRevoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRevoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRevoked?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      isRevoked: boolean
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model OtpAttempt
   */

  export type AggregateOtpAttempt = {
    _count: OtpAttemptCountAggregateOutputType | null
    _avg: OtpAttemptAvgAggregateOutputType | null
    _sum: OtpAttemptSumAggregateOutputType | null
    _min: OtpAttemptMinAggregateOutputType | null
    _max: OtpAttemptMaxAggregateOutputType | null
  }

  export type OtpAttemptAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OtpAttemptSumAggregateOutputType = {
    attempts: number | null
  }

  export type OtpAttemptMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    otpCode: string | null
    attempts: number | null
    isVerified: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type OtpAttemptMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    otpCode: string | null
    attempts: number | null
    isVerified: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type OtpAttemptCountAggregateOutputType = {
    id: number
    phoneNumber: number
    otpCode: number
    attempts: number
    isVerified: number
    expiresAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type OtpAttemptAvgAggregateInputType = {
    attempts?: true
  }

  export type OtpAttemptSumAggregateInputType = {
    attempts?: true
  }

  export type OtpAttemptMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    otpCode?: true
    attempts?: true
    isVerified?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type OtpAttemptMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    otpCode?: true
    attempts?: true
    isVerified?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type OtpAttemptCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    otpCode?: true
    attempts?: true
    isVerified?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type OtpAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpAttempt to aggregate.
     */
    where?: OtpAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpAttempts to fetch.
     */
    orderBy?: OtpAttemptOrderByWithRelationInput | OtpAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtpAttempts
    **/
    _count?: true | OtpAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpAttemptMaxAggregateInputType
  }

  export type GetOtpAttemptAggregateType<T extends OtpAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateOtpAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtpAttempt[P]>
      : GetScalarType<T[P], AggregateOtpAttempt[P]>
  }




  export type OtpAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpAttemptWhereInput
    orderBy?: OtpAttemptOrderByWithAggregationInput | OtpAttemptOrderByWithAggregationInput[]
    by: OtpAttemptScalarFieldEnum[] | OtpAttemptScalarFieldEnum
    having?: OtpAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpAttemptCountAggregateInputType | true
    _avg?: OtpAttemptAvgAggregateInputType
    _sum?: OtpAttemptSumAggregateInputType
    _min?: OtpAttemptMinAggregateInputType
    _max?: OtpAttemptMaxAggregateInputType
  }

  export type OtpAttemptGroupByOutputType = {
    id: string
    phoneNumber: string
    otpCode: string
    attempts: number
    isVerified: boolean
    expiresAt: Date
    createdAt: Date
    userId: string | null
    _count: OtpAttemptCountAggregateOutputType | null
    _avg: OtpAttemptAvgAggregateOutputType | null
    _sum: OtpAttemptSumAggregateOutputType | null
    _min: OtpAttemptMinAggregateOutputType | null
    _max: OtpAttemptMaxAggregateOutputType | null
  }

  type GetOtpAttemptGroupByPayload<T extends OtpAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], OtpAttemptGroupByOutputType[P]>
        }
      >
    >


  export type OtpAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    otpCode?: boolean
    attempts?: boolean
    isVerified?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | OtpAttempt$userArgs<ExtArgs>
  }, ExtArgs["result"]["otpAttempt"]>

  export type OtpAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    otpCode?: boolean
    attempts?: boolean
    isVerified?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | OtpAttempt$userArgs<ExtArgs>
  }, ExtArgs["result"]["otpAttempt"]>

  export type OtpAttemptSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    otpCode?: boolean
    attempts?: boolean
    isVerified?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type OtpAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpAttempt$userArgs<ExtArgs>
  }
  export type OtpAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpAttempt$userArgs<ExtArgs>
  }

  export type $OtpAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtpAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      otpCode: string
      attempts: number
      isVerified: boolean
      expiresAt: Date
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["otpAttempt"]>
    composites: {}
  }

  type OtpAttemptGetPayload<S extends boolean | null | undefined | OtpAttemptDefaultArgs> = $Result.GetResult<Prisma.$OtpAttemptPayload, S>

  type OtpAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtpAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtpAttemptCountAggregateInputType | true
    }

  export interface OtpAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtpAttempt'], meta: { name: 'OtpAttempt' } }
    /**
     * Find zero or one OtpAttempt that matches the filter.
     * @param {OtpAttemptFindUniqueArgs} args - Arguments to find a OtpAttempt
     * @example
     * // Get one OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpAttemptFindUniqueArgs>(args: SelectSubset<T, OtpAttemptFindUniqueArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OtpAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtpAttemptFindUniqueOrThrowArgs} args - Arguments to find a OtpAttempt
     * @example
     * // Get one OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OtpAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptFindFirstArgs} args - Arguments to find a OtpAttempt
     * @example
     * // Get one OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpAttemptFindFirstArgs>(args?: SelectSubset<T, OtpAttemptFindFirstArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OtpAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptFindFirstOrThrowArgs} args - Arguments to find a OtpAttempt
     * @example
     * // Get one OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OtpAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtpAttempts
     * const otpAttempts = await prisma.otpAttempt.findMany()
     * 
     * // Get first 10 OtpAttempts
     * const otpAttempts = await prisma.otpAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpAttemptWithIdOnly = await prisma.otpAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpAttemptFindManyArgs>(args?: SelectSubset<T, OtpAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OtpAttempt.
     * @param {OtpAttemptCreateArgs} args - Arguments to create a OtpAttempt.
     * @example
     * // Create one OtpAttempt
     * const OtpAttempt = await prisma.otpAttempt.create({
     *   data: {
     *     // ... data to create a OtpAttempt
     *   }
     * })
     * 
     */
    create<T extends OtpAttemptCreateArgs>(args: SelectSubset<T, OtpAttemptCreateArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OtpAttempts.
     * @param {OtpAttemptCreateManyArgs} args - Arguments to create many OtpAttempts.
     * @example
     * // Create many OtpAttempts
     * const otpAttempt = await prisma.otpAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpAttemptCreateManyArgs>(args?: SelectSubset<T, OtpAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtpAttempts and returns the data saved in the database.
     * @param {OtpAttemptCreateManyAndReturnArgs} args - Arguments to create many OtpAttempts.
     * @example
     * // Create many OtpAttempts
     * const otpAttempt = await prisma.otpAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtpAttempts and only return the `id`
     * const otpAttemptWithIdOnly = await prisma.otpAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OtpAttempt.
     * @param {OtpAttemptDeleteArgs} args - Arguments to delete one OtpAttempt.
     * @example
     * // Delete one OtpAttempt
     * const OtpAttempt = await prisma.otpAttempt.delete({
     *   where: {
     *     // ... filter to delete one OtpAttempt
     *   }
     * })
     * 
     */
    delete<T extends OtpAttemptDeleteArgs>(args: SelectSubset<T, OtpAttemptDeleteArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OtpAttempt.
     * @param {OtpAttemptUpdateArgs} args - Arguments to update one OtpAttempt.
     * @example
     * // Update one OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpAttemptUpdateArgs>(args: SelectSubset<T, OtpAttemptUpdateArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OtpAttempts.
     * @param {OtpAttemptDeleteManyArgs} args - Arguments to filter OtpAttempts to delete.
     * @example
     * // Delete a few OtpAttempts
     * const { count } = await prisma.otpAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpAttemptDeleteManyArgs>(args?: SelectSubset<T, OtpAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtpAttempts
     * const otpAttempt = await prisma.otpAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpAttemptUpdateManyArgs>(args: SelectSubset<T, OtpAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtpAttempt.
     * @param {OtpAttemptUpsertArgs} args - Arguments to update or create a OtpAttempt.
     * @example
     * // Update or create a OtpAttempt
     * const otpAttempt = await prisma.otpAttempt.upsert({
     *   create: {
     *     // ... data to create a OtpAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtpAttempt we want to update
     *   }
     * })
     */
    upsert<T extends OtpAttemptUpsertArgs>(args: SelectSubset<T, OtpAttemptUpsertArgs<ExtArgs>>): Prisma__OtpAttemptClient<$Result.GetResult<Prisma.$OtpAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OtpAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptCountArgs} args - Arguments to filter OtpAttempts to count.
     * @example
     * // Count the number of OtpAttempts
     * const count = await prisma.otpAttempt.count({
     *   where: {
     *     // ... the filter for the OtpAttempts we want to count
     *   }
     * })
    **/
    count<T extends OtpAttemptCountArgs>(
      args?: Subset<T, OtpAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtpAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAttemptAggregateArgs>(args: Subset<T, OtpAttemptAggregateArgs>): Prisma.PrismaPromise<GetOtpAttemptAggregateType<T>>

    /**
     * Group by OtpAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpAttemptGroupByArgs['orderBy'] }
        : { orderBy?: OtpAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtpAttempt model
   */
  readonly fields: OtpAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtpAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends OtpAttempt$userArgs<ExtArgs> = {}>(args?: Subset<T, OtpAttempt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtpAttempt model
   */ 
  interface OtpAttemptFieldRefs {
    readonly id: FieldRef<"OtpAttempt", 'String'>
    readonly phoneNumber: FieldRef<"OtpAttempt", 'String'>
    readonly otpCode: FieldRef<"OtpAttempt", 'String'>
    readonly attempts: FieldRef<"OtpAttempt", 'Int'>
    readonly isVerified: FieldRef<"OtpAttempt", 'Boolean'>
    readonly expiresAt: FieldRef<"OtpAttempt", 'DateTime'>
    readonly createdAt: FieldRef<"OtpAttempt", 'DateTime'>
    readonly userId: FieldRef<"OtpAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OtpAttempt findUnique
   */
  export type OtpAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter, which OtpAttempt to fetch.
     */
    where: OtpAttemptWhereUniqueInput
  }

  /**
   * OtpAttempt findUniqueOrThrow
   */
  export type OtpAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter, which OtpAttempt to fetch.
     */
    where: OtpAttemptWhereUniqueInput
  }

  /**
   * OtpAttempt findFirst
   */
  export type OtpAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter, which OtpAttempt to fetch.
     */
    where?: OtpAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpAttempts to fetch.
     */
    orderBy?: OtpAttemptOrderByWithRelationInput | OtpAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpAttempts.
     */
    cursor?: OtpAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpAttempts.
     */
    distinct?: OtpAttemptScalarFieldEnum | OtpAttemptScalarFieldEnum[]
  }

  /**
   * OtpAttempt findFirstOrThrow
   */
  export type OtpAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter, which OtpAttempt to fetch.
     */
    where?: OtpAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpAttempts to fetch.
     */
    orderBy?: OtpAttemptOrderByWithRelationInput | OtpAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpAttempts.
     */
    cursor?: OtpAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpAttempts.
     */
    distinct?: OtpAttemptScalarFieldEnum | OtpAttemptScalarFieldEnum[]
  }

  /**
   * OtpAttempt findMany
   */
  export type OtpAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter, which OtpAttempts to fetch.
     */
    where?: OtpAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpAttempts to fetch.
     */
    orderBy?: OtpAttemptOrderByWithRelationInput | OtpAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtpAttempts.
     */
    cursor?: OtpAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpAttempts.
     */
    skip?: number
    distinct?: OtpAttemptScalarFieldEnum | OtpAttemptScalarFieldEnum[]
  }

  /**
   * OtpAttempt create
   */
  export type OtpAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a OtpAttempt.
     */
    data: XOR<OtpAttemptCreateInput, OtpAttemptUncheckedCreateInput>
  }

  /**
   * OtpAttempt createMany
   */
  export type OtpAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtpAttempts.
     */
    data: OtpAttemptCreateManyInput | OtpAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpAttempt createManyAndReturn
   */
  export type OtpAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OtpAttempts.
     */
    data: OtpAttemptCreateManyInput | OtpAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtpAttempt update
   */
  export type OtpAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a OtpAttempt.
     */
    data: XOR<OtpAttemptUpdateInput, OtpAttemptUncheckedUpdateInput>
    /**
     * Choose, which OtpAttempt to update.
     */
    where: OtpAttemptWhereUniqueInput
  }

  /**
   * OtpAttempt updateMany
   */
  export type OtpAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtpAttempts.
     */
    data: XOR<OtpAttemptUpdateManyMutationInput, OtpAttemptUncheckedUpdateManyInput>
    /**
     * Filter which OtpAttempts to update
     */
    where?: OtpAttemptWhereInput
  }

  /**
   * OtpAttempt upsert
   */
  export type OtpAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the OtpAttempt to update in case it exists.
     */
    where: OtpAttemptWhereUniqueInput
    /**
     * In case the OtpAttempt found by the `where` argument doesn't exist, create a new OtpAttempt with this data.
     */
    create: XOR<OtpAttemptCreateInput, OtpAttemptUncheckedCreateInput>
    /**
     * In case the OtpAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpAttemptUpdateInput, OtpAttemptUncheckedUpdateInput>
  }

  /**
   * OtpAttempt delete
   */
  export type OtpAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
    /**
     * Filter which OtpAttempt to delete.
     */
    where: OtpAttemptWhereUniqueInput
  }

  /**
   * OtpAttempt deleteMany
   */
  export type OtpAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpAttempts to delete
     */
    where?: OtpAttemptWhereInput
  }

  /**
   * OtpAttempt.user
   */
  export type OtpAttempt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OtpAttempt without action
   */
  export type OtpAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpAttempt
     */
    select?: OtpAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpAttemptInclude<ExtArgs> | null
  }


  /**
   * Model SignalIdentity
   */

  export type AggregateSignalIdentity = {
    _count: SignalIdentityCountAggregateOutputType | null
    _avg: SignalIdentityAvgAggregateOutputType | null
    _sum: SignalIdentitySumAggregateOutputType | null
    _min: SignalIdentityMinAggregateOutputType | null
    _max: SignalIdentityMaxAggregateOutputType | null
  }

  export type SignalIdentityAvgAggregateOutputType = {
    deviceId: number | null
    registrationId: number | null
  }

  export type SignalIdentitySumAggregateOutputType = {
    deviceId: number | null
    registrationId: number | null
  }

  export type SignalIdentityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: number | null
    identityPublicKey: string | null
    identityPrivateKey: string | null
    registrationId: number | null
    createdAt: Date | null
  }

  export type SignalIdentityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: number | null
    identityPublicKey: string | null
    identityPrivateKey: string | null
    registrationId: number | null
    createdAt: Date | null
  }

  export type SignalIdentityCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    identityPublicKey: number
    identityPrivateKey: number
    registrationId: number
    createdAt: number
    _all: number
  }


  export type SignalIdentityAvgAggregateInputType = {
    deviceId?: true
    registrationId?: true
  }

  export type SignalIdentitySumAggregateInputType = {
    deviceId?: true
    registrationId?: true
  }

  export type SignalIdentityMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    identityPublicKey?: true
    identityPrivateKey?: true
    registrationId?: true
    createdAt?: true
  }

  export type SignalIdentityMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    identityPublicKey?: true
    identityPrivateKey?: true
    registrationId?: true
    createdAt?: true
  }

  export type SignalIdentityCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    identityPublicKey?: true
    identityPrivateKey?: true
    registrationId?: true
    createdAt?: true
    _all?: true
  }

  export type SignalIdentityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalIdentity to aggregate.
     */
    where?: SignalIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalIdentities to fetch.
     */
    orderBy?: SignalIdentityOrderByWithRelationInput | SignalIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignalIdentities
    **/
    _count?: true | SignalIdentityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalIdentityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalIdentitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalIdentityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalIdentityMaxAggregateInputType
  }

  export type GetSignalIdentityAggregateType<T extends SignalIdentityAggregateArgs> = {
        [P in keyof T & keyof AggregateSignalIdentity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignalIdentity[P]>
      : GetScalarType<T[P], AggregateSignalIdentity[P]>
  }




  export type SignalIdentityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalIdentityWhereInput
    orderBy?: SignalIdentityOrderByWithAggregationInput | SignalIdentityOrderByWithAggregationInput[]
    by: SignalIdentityScalarFieldEnum[] | SignalIdentityScalarFieldEnum
    having?: SignalIdentityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalIdentityCountAggregateInputType | true
    _avg?: SignalIdentityAvgAggregateInputType
    _sum?: SignalIdentitySumAggregateInputType
    _min?: SignalIdentityMinAggregateInputType
    _max?: SignalIdentityMaxAggregateInputType
  }

  export type SignalIdentityGroupByOutputType = {
    id: string
    userId: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt: Date
    _count: SignalIdentityCountAggregateOutputType | null
    _avg: SignalIdentityAvgAggregateOutputType | null
    _sum: SignalIdentitySumAggregateOutputType | null
    _min: SignalIdentityMinAggregateOutputType | null
    _max: SignalIdentityMaxAggregateOutputType | null
  }

  type GetSignalIdentityGroupByPayload<T extends SignalIdentityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalIdentityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalIdentityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalIdentityGroupByOutputType[P]>
            : GetScalarType<T[P], SignalIdentityGroupByOutputType[P]>
        }
      >
    >


  export type SignalIdentitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    identityPublicKey?: boolean
    identityPrivateKey?: boolean
    registrationId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signalIdentity"]>

  export type SignalIdentitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    identityPublicKey?: boolean
    identityPrivateKey?: boolean
    registrationId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signalIdentity"]>

  export type SignalIdentitySelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    identityPublicKey?: boolean
    identityPrivateKey?: boolean
    registrationId?: boolean
    createdAt?: boolean
  }

  export type SignalIdentityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SignalIdentityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SignalIdentityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SignalIdentity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceId: number
      identityPublicKey: string
      identityPrivateKey: string
      registrationId: number
      createdAt: Date
    }, ExtArgs["result"]["signalIdentity"]>
    composites: {}
  }

  type SignalIdentityGetPayload<S extends boolean | null | undefined | SignalIdentityDefaultArgs> = $Result.GetResult<Prisma.$SignalIdentityPayload, S>

  type SignalIdentityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignalIdentityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignalIdentityCountAggregateInputType | true
    }

  export interface SignalIdentityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SignalIdentity'], meta: { name: 'SignalIdentity' } }
    /**
     * Find zero or one SignalIdentity that matches the filter.
     * @param {SignalIdentityFindUniqueArgs} args - Arguments to find a SignalIdentity
     * @example
     * // Get one SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalIdentityFindUniqueArgs>(args: SelectSubset<T, SignalIdentityFindUniqueArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SignalIdentity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignalIdentityFindUniqueOrThrowArgs} args - Arguments to find a SignalIdentity
     * @example
     * // Get one SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalIdentityFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalIdentityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SignalIdentity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityFindFirstArgs} args - Arguments to find a SignalIdentity
     * @example
     * // Get one SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalIdentityFindFirstArgs>(args?: SelectSubset<T, SignalIdentityFindFirstArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SignalIdentity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityFindFirstOrThrowArgs} args - Arguments to find a SignalIdentity
     * @example
     * // Get one SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalIdentityFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalIdentityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SignalIdentities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignalIdentities
     * const signalIdentities = await prisma.signalIdentity.findMany()
     * 
     * // Get first 10 SignalIdentities
     * const signalIdentities = await prisma.signalIdentity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalIdentityWithIdOnly = await prisma.signalIdentity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalIdentityFindManyArgs>(args?: SelectSubset<T, SignalIdentityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SignalIdentity.
     * @param {SignalIdentityCreateArgs} args - Arguments to create a SignalIdentity.
     * @example
     * // Create one SignalIdentity
     * const SignalIdentity = await prisma.signalIdentity.create({
     *   data: {
     *     // ... data to create a SignalIdentity
     *   }
     * })
     * 
     */
    create<T extends SignalIdentityCreateArgs>(args: SelectSubset<T, SignalIdentityCreateArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SignalIdentities.
     * @param {SignalIdentityCreateManyArgs} args - Arguments to create many SignalIdentities.
     * @example
     * // Create many SignalIdentities
     * const signalIdentity = await prisma.signalIdentity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalIdentityCreateManyArgs>(args?: SelectSubset<T, SignalIdentityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SignalIdentities and returns the data saved in the database.
     * @param {SignalIdentityCreateManyAndReturnArgs} args - Arguments to create many SignalIdentities.
     * @example
     * // Create many SignalIdentities
     * const signalIdentity = await prisma.signalIdentity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SignalIdentities and only return the `id`
     * const signalIdentityWithIdOnly = await prisma.signalIdentity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalIdentityCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalIdentityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SignalIdentity.
     * @param {SignalIdentityDeleteArgs} args - Arguments to delete one SignalIdentity.
     * @example
     * // Delete one SignalIdentity
     * const SignalIdentity = await prisma.signalIdentity.delete({
     *   where: {
     *     // ... filter to delete one SignalIdentity
     *   }
     * })
     * 
     */
    delete<T extends SignalIdentityDeleteArgs>(args: SelectSubset<T, SignalIdentityDeleteArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SignalIdentity.
     * @param {SignalIdentityUpdateArgs} args - Arguments to update one SignalIdentity.
     * @example
     * // Update one SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalIdentityUpdateArgs>(args: SelectSubset<T, SignalIdentityUpdateArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SignalIdentities.
     * @param {SignalIdentityDeleteManyArgs} args - Arguments to filter SignalIdentities to delete.
     * @example
     * // Delete a few SignalIdentities
     * const { count } = await prisma.signalIdentity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalIdentityDeleteManyArgs>(args?: SelectSubset<T, SignalIdentityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignalIdentities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignalIdentities
     * const signalIdentity = await prisma.signalIdentity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalIdentityUpdateManyArgs>(args: SelectSubset<T, SignalIdentityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SignalIdentity.
     * @param {SignalIdentityUpsertArgs} args - Arguments to update or create a SignalIdentity.
     * @example
     * // Update or create a SignalIdentity
     * const signalIdentity = await prisma.signalIdentity.upsert({
     *   create: {
     *     // ... data to create a SignalIdentity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignalIdentity we want to update
     *   }
     * })
     */
    upsert<T extends SignalIdentityUpsertArgs>(args: SelectSubset<T, SignalIdentityUpsertArgs<ExtArgs>>): Prisma__SignalIdentityClient<$Result.GetResult<Prisma.$SignalIdentityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SignalIdentities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityCountArgs} args - Arguments to filter SignalIdentities to count.
     * @example
     * // Count the number of SignalIdentities
     * const count = await prisma.signalIdentity.count({
     *   where: {
     *     // ... the filter for the SignalIdentities we want to count
     *   }
     * })
    **/
    count<T extends SignalIdentityCountArgs>(
      args?: Subset<T, SignalIdentityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalIdentityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignalIdentity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalIdentityAggregateArgs>(args: Subset<T, SignalIdentityAggregateArgs>): Prisma.PrismaPromise<GetSignalIdentityAggregateType<T>>

    /**
     * Group by SignalIdentity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalIdentityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalIdentityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalIdentityGroupByArgs['orderBy'] }
        : { orderBy?: SignalIdentityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalIdentityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalIdentityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SignalIdentity model
   */
  readonly fields: SignalIdentityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignalIdentity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalIdentityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SignalIdentity model
   */ 
  interface SignalIdentityFieldRefs {
    readonly id: FieldRef<"SignalIdentity", 'String'>
    readonly userId: FieldRef<"SignalIdentity", 'String'>
    readonly deviceId: FieldRef<"SignalIdentity", 'Int'>
    readonly identityPublicKey: FieldRef<"SignalIdentity", 'String'>
    readonly identityPrivateKey: FieldRef<"SignalIdentity", 'String'>
    readonly registrationId: FieldRef<"SignalIdentity", 'Int'>
    readonly createdAt: FieldRef<"SignalIdentity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SignalIdentity findUnique
   */
  export type SignalIdentityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SignalIdentity to fetch.
     */
    where: SignalIdentityWhereUniqueInput
  }

  /**
   * SignalIdentity findUniqueOrThrow
   */
  export type SignalIdentityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SignalIdentity to fetch.
     */
    where: SignalIdentityWhereUniqueInput
  }

  /**
   * SignalIdentity findFirst
   */
  export type SignalIdentityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SignalIdentity to fetch.
     */
    where?: SignalIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalIdentities to fetch.
     */
    orderBy?: SignalIdentityOrderByWithRelationInput | SignalIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalIdentities.
     */
    cursor?: SignalIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalIdentities.
     */
    distinct?: SignalIdentityScalarFieldEnum | SignalIdentityScalarFieldEnum[]
  }

  /**
   * SignalIdentity findFirstOrThrow
   */
  export type SignalIdentityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SignalIdentity to fetch.
     */
    where?: SignalIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalIdentities to fetch.
     */
    orderBy?: SignalIdentityOrderByWithRelationInput | SignalIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalIdentities.
     */
    cursor?: SignalIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalIdentities.
     */
    distinct?: SignalIdentityScalarFieldEnum | SignalIdentityScalarFieldEnum[]
  }

  /**
   * SignalIdentity findMany
   */
  export type SignalIdentityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SignalIdentities to fetch.
     */
    where?: SignalIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalIdentities to fetch.
     */
    orderBy?: SignalIdentityOrderByWithRelationInput | SignalIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignalIdentities.
     */
    cursor?: SignalIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalIdentities.
     */
    skip?: number
    distinct?: SignalIdentityScalarFieldEnum | SignalIdentityScalarFieldEnum[]
  }

  /**
   * SignalIdentity create
   */
  export type SignalIdentityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * The data needed to create a SignalIdentity.
     */
    data: XOR<SignalIdentityCreateInput, SignalIdentityUncheckedCreateInput>
  }

  /**
   * SignalIdentity createMany
   */
  export type SignalIdentityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SignalIdentities.
     */
    data: SignalIdentityCreateManyInput | SignalIdentityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignalIdentity createManyAndReturn
   */
  export type SignalIdentityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SignalIdentities.
     */
    data: SignalIdentityCreateManyInput | SignalIdentityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SignalIdentity update
   */
  export type SignalIdentityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * The data needed to update a SignalIdentity.
     */
    data: XOR<SignalIdentityUpdateInput, SignalIdentityUncheckedUpdateInput>
    /**
     * Choose, which SignalIdentity to update.
     */
    where: SignalIdentityWhereUniqueInput
  }

  /**
   * SignalIdentity updateMany
   */
  export type SignalIdentityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SignalIdentities.
     */
    data: XOR<SignalIdentityUpdateManyMutationInput, SignalIdentityUncheckedUpdateManyInput>
    /**
     * Filter which SignalIdentities to update
     */
    where?: SignalIdentityWhereInput
  }

  /**
   * SignalIdentity upsert
   */
  export type SignalIdentityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * The filter to search for the SignalIdentity to update in case it exists.
     */
    where: SignalIdentityWhereUniqueInput
    /**
     * In case the SignalIdentity found by the `where` argument doesn't exist, create a new SignalIdentity with this data.
     */
    create: XOR<SignalIdentityCreateInput, SignalIdentityUncheckedCreateInput>
    /**
     * In case the SignalIdentity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalIdentityUpdateInput, SignalIdentityUncheckedUpdateInput>
  }

  /**
   * SignalIdentity delete
   */
  export type SignalIdentityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
    /**
     * Filter which SignalIdentity to delete.
     */
    where: SignalIdentityWhereUniqueInput
  }

  /**
   * SignalIdentity deleteMany
   */
  export type SignalIdentityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalIdentities to delete
     */
    where?: SignalIdentityWhereInput
  }

  /**
   * SignalIdentity without action
   */
  export type SignalIdentityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalIdentity
     */
    select?: SignalIdentitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIdentityInclude<ExtArgs> | null
  }


  /**
   * Model SignalSession
   */

  export type AggregateSignalSession = {
    _count: SignalSessionCountAggregateOutputType | null
    _avg: SignalSessionAvgAggregateOutputType | null
    _sum: SignalSessionSumAggregateOutputType | null
    _min: SignalSessionMinAggregateOutputType | null
    _max: SignalSessionMaxAggregateOutputType | null
  }

  export type SignalSessionAvgAggregateOutputType = {
    deviceId: number | null
  }

  export type SignalSessionSumAggregateOutputType = {
    deviceId: number | null
  }

  export type SignalSessionMinAggregateOutputType = {
    id: string | null
    localUserId: string | null
    remoteUserId: string | null
    deviceId: number | null
    sessionData: string | null
    createdAt: Date | null
    lastUsed: Date | null
  }

  export type SignalSessionMaxAggregateOutputType = {
    id: string | null
    localUserId: string | null
    remoteUserId: string | null
    deviceId: number | null
    sessionData: string | null
    createdAt: Date | null
    lastUsed: Date | null
  }

  export type SignalSessionCountAggregateOutputType = {
    id: number
    localUserId: number
    remoteUserId: number
    deviceId: number
    sessionData: number
    createdAt: number
    lastUsed: number
    _all: number
  }


  export type SignalSessionAvgAggregateInputType = {
    deviceId?: true
  }

  export type SignalSessionSumAggregateInputType = {
    deviceId?: true
  }

  export type SignalSessionMinAggregateInputType = {
    id?: true
    localUserId?: true
    remoteUserId?: true
    deviceId?: true
    sessionData?: true
    createdAt?: true
    lastUsed?: true
  }

  export type SignalSessionMaxAggregateInputType = {
    id?: true
    localUserId?: true
    remoteUserId?: true
    deviceId?: true
    sessionData?: true
    createdAt?: true
    lastUsed?: true
  }

  export type SignalSessionCountAggregateInputType = {
    id?: true
    localUserId?: true
    remoteUserId?: true
    deviceId?: true
    sessionData?: true
    createdAt?: true
    lastUsed?: true
    _all?: true
  }

  export type SignalSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalSession to aggregate.
     */
    where?: SignalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalSessions to fetch.
     */
    orderBy?: SignalSessionOrderByWithRelationInput | SignalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignalSessions
    **/
    _count?: true | SignalSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalSessionMaxAggregateInputType
  }

  export type GetSignalSessionAggregateType<T extends SignalSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSignalSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignalSession[P]>
      : GetScalarType<T[P], AggregateSignalSession[P]>
  }




  export type SignalSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalSessionWhereInput
    orderBy?: SignalSessionOrderByWithAggregationInput | SignalSessionOrderByWithAggregationInput[]
    by: SignalSessionScalarFieldEnum[] | SignalSessionScalarFieldEnum
    having?: SignalSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalSessionCountAggregateInputType | true
    _avg?: SignalSessionAvgAggregateInputType
    _sum?: SignalSessionSumAggregateInputType
    _min?: SignalSessionMinAggregateInputType
    _max?: SignalSessionMaxAggregateInputType
  }

  export type SignalSessionGroupByOutputType = {
    id: string
    localUserId: string
    remoteUserId: string
    deviceId: number
    sessionData: string
    createdAt: Date
    lastUsed: Date
    _count: SignalSessionCountAggregateOutputType | null
    _avg: SignalSessionAvgAggregateOutputType | null
    _sum: SignalSessionSumAggregateOutputType | null
    _min: SignalSessionMinAggregateOutputType | null
    _max: SignalSessionMaxAggregateOutputType | null
  }

  type GetSignalSessionGroupByPayload<T extends SignalSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SignalSessionGroupByOutputType[P]>
        }
      >
    >


  export type SignalSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localUserId?: boolean
    remoteUserId?: boolean
    deviceId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    lastUsed?: boolean
  }, ExtArgs["result"]["signalSession"]>

  export type SignalSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localUserId?: boolean
    remoteUserId?: boolean
    deviceId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    lastUsed?: boolean
  }, ExtArgs["result"]["signalSession"]>

  export type SignalSessionSelectScalar = {
    id?: boolean
    localUserId?: boolean
    remoteUserId?: boolean
    deviceId?: boolean
    sessionData?: boolean
    createdAt?: boolean
    lastUsed?: boolean
  }


  export type $SignalSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SignalSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localUserId: string
      remoteUserId: string
      deviceId: number
      sessionData: string
      createdAt: Date
      lastUsed: Date
    }, ExtArgs["result"]["signalSession"]>
    composites: {}
  }

  type SignalSessionGetPayload<S extends boolean | null | undefined | SignalSessionDefaultArgs> = $Result.GetResult<Prisma.$SignalSessionPayload, S>

  type SignalSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignalSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignalSessionCountAggregateInputType | true
    }

  export interface SignalSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SignalSession'], meta: { name: 'SignalSession' } }
    /**
     * Find zero or one SignalSession that matches the filter.
     * @param {SignalSessionFindUniqueArgs} args - Arguments to find a SignalSession
     * @example
     * // Get one SignalSession
     * const signalSession = await prisma.signalSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalSessionFindUniqueArgs>(args: SelectSubset<T, SignalSessionFindUniqueArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SignalSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignalSessionFindUniqueOrThrowArgs} args - Arguments to find a SignalSession
     * @example
     * // Get one SignalSession
     * const signalSession = await prisma.signalSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SignalSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionFindFirstArgs} args - Arguments to find a SignalSession
     * @example
     * // Get one SignalSession
     * const signalSession = await prisma.signalSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalSessionFindFirstArgs>(args?: SelectSubset<T, SignalSessionFindFirstArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SignalSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionFindFirstOrThrowArgs} args - Arguments to find a SignalSession
     * @example
     * // Get one SignalSession
     * const signalSession = await prisma.signalSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SignalSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignalSessions
     * const signalSessions = await prisma.signalSession.findMany()
     * 
     * // Get first 10 SignalSessions
     * const signalSessions = await prisma.signalSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalSessionWithIdOnly = await prisma.signalSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalSessionFindManyArgs>(args?: SelectSubset<T, SignalSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SignalSession.
     * @param {SignalSessionCreateArgs} args - Arguments to create a SignalSession.
     * @example
     * // Create one SignalSession
     * const SignalSession = await prisma.signalSession.create({
     *   data: {
     *     // ... data to create a SignalSession
     *   }
     * })
     * 
     */
    create<T extends SignalSessionCreateArgs>(args: SelectSubset<T, SignalSessionCreateArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SignalSessions.
     * @param {SignalSessionCreateManyArgs} args - Arguments to create many SignalSessions.
     * @example
     * // Create many SignalSessions
     * const signalSession = await prisma.signalSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalSessionCreateManyArgs>(args?: SelectSubset<T, SignalSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SignalSessions and returns the data saved in the database.
     * @param {SignalSessionCreateManyAndReturnArgs} args - Arguments to create many SignalSessions.
     * @example
     * // Create many SignalSessions
     * const signalSession = await prisma.signalSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SignalSessions and only return the `id`
     * const signalSessionWithIdOnly = await prisma.signalSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SignalSession.
     * @param {SignalSessionDeleteArgs} args - Arguments to delete one SignalSession.
     * @example
     * // Delete one SignalSession
     * const SignalSession = await prisma.signalSession.delete({
     *   where: {
     *     // ... filter to delete one SignalSession
     *   }
     * })
     * 
     */
    delete<T extends SignalSessionDeleteArgs>(args: SelectSubset<T, SignalSessionDeleteArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SignalSession.
     * @param {SignalSessionUpdateArgs} args - Arguments to update one SignalSession.
     * @example
     * // Update one SignalSession
     * const signalSession = await prisma.signalSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalSessionUpdateArgs>(args: SelectSubset<T, SignalSessionUpdateArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SignalSessions.
     * @param {SignalSessionDeleteManyArgs} args - Arguments to filter SignalSessions to delete.
     * @example
     * // Delete a few SignalSessions
     * const { count } = await prisma.signalSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalSessionDeleteManyArgs>(args?: SelectSubset<T, SignalSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignalSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignalSessions
     * const signalSession = await prisma.signalSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalSessionUpdateManyArgs>(args: SelectSubset<T, SignalSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SignalSession.
     * @param {SignalSessionUpsertArgs} args - Arguments to update or create a SignalSession.
     * @example
     * // Update or create a SignalSession
     * const signalSession = await prisma.signalSession.upsert({
     *   create: {
     *     // ... data to create a SignalSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignalSession we want to update
     *   }
     * })
     */
    upsert<T extends SignalSessionUpsertArgs>(args: SelectSubset<T, SignalSessionUpsertArgs<ExtArgs>>): Prisma__SignalSessionClient<$Result.GetResult<Prisma.$SignalSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SignalSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionCountArgs} args - Arguments to filter SignalSessions to count.
     * @example
     * // Count the number of SignalSessions
     * const count = await prisma.signalSession.count({
     *   where: {
     *     // ... the filter for the SignalSessions we want to count
     *   }
     * })
    **/
    count<T extends SignalSessionCountArgs>(
      args?: Subset<T, SignalSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignalSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalSessionAggregateArgs>(args: Subset<T, SignalSessionAggregateArgs>): Prisma.PrismaPromise<GetSignalSessionAggregateType<T>>

    /**
     * Group by SignalSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalSessionGroupByArgs['orderBy'] }
        : { orderBy?: SignalSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SignalSession model
   */
  readonly fields: SignalSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignalSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SignalSession model
   */ 
  interface SignalSessionFieldRefs {
    readonly id: FieldRef<"SignalSession", 'String'>
    readonly localUserId: FieldRef<"SignalSession", 'String'>
    readonly remoteUserId: FieldRef<"SignalSession", 'String'>
    readonly deviceId: FieldRef<"SignalSession", 'Int'>
    readonly sessionData: FieldRef<"SignalSession", 'String'>
    readonly createdAt: FieldRef<"SignalSession", 'DateTime'>
    readonly lastUsed: FieldRef<"SignalSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SignalSession findUnique
   */
  export type SignalSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter, which SignalSession to fetch.
     */
    where: SignalSessionWhereUniqueInput
  }

  /**
   * SignalSession findUniqueOrThrow
   */
  export type SignalSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter, which SignalSession to fetch.
     */
    where: SignalSessionWhereUniqueInput
  }

  /**
   * SignalSession findFirst
   */
  export type SignalSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter, which SignalSession to fetch.
     */
    where?: SignalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalSessions to fetch.
     */
    orderBy?: SignalSessionOrderByWithRelationInput | SignalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalSessions.
     */
    cursor?: SignalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalSessions.
     */
    distinct?: SignalSessionScalarFieldEnum | SignalSessionScalarFieldEnum[]
  }

  /**
   * SignalSession findFirstOrThrow
   */
  export type SignalSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter, which SignalSession to fetch.
     */
    where?: SignalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalSessions to fetch.
     */
    orderBy?: SignalSessionOrderByWithRelationInput | SignalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalSessions.
     */
    cursor?: SignalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalSessions.
     */
    distinct?: SignalSessionScalarFieldEnum | SignalSessionScalarFieldEnum[]
  }

  /**
   * SignalSession findMany
   */
  export type SignalSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter, which SignalSessions to fetch.
     */
    where?: SignalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalSessions to fetch.
     */
    orderBy?: SignalSessionOrderByWithRelationInput | SignalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignalSessions.
     */
    cursor?: SignalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalSessions.
     */
    skip?: number
    distinct?: SignalSessionScalarFieldEnum | SignalSessionScalarFieldEnum[]
  }

  /**
   * SignalSession create
   */
  export type SignalSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * The data needed to create a SignalSession.
     */
    data: XOR<SignalSessionCreateInput, SignalSessionUncheckedCreateInput>
  }

  /**
   * SignalSession createMany
   */
  export type SignalSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SignalSessions.
     */
    data: SignalSessionCreateManyInput | SignalSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignalSession createManyAndReturn
   */
  export type SignalSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SignalSessions.
     */
    data: SignalSessionCreateManyInput | SignalSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignalSession update
   */
  export type SignalSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * The data needed to update a SignalSession.
     */
    data: XOR<SignalSessionUpdateInput, SignalSessionUncheckedUpdateInput>
    /**
     * Choose, which SignalSession to update.
     */
    where: SignalSessionWhereUniqueInput
  }

  /**
   * SignalSession updateMany
   */
  export type SignalSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SignalSessions.
     */
    data: XOR<SignalSessionUpdateManyMutationInput, SignalSessionUncheckedUpdateManyInput>
    /**
     * Filter which SignalSessions to update
     */
    where?: SignalSessionWhereInput
  }

  /**
   * SignalSession upsert
   */
  export type SignalSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * The filter to search for the SignalSession to update in case it exists.
     */
    where: SignalSessionWhereUniqueInput
    /**
     * In case the SignalSession found by the `where` argument doesn't exist, create a new SignalSession with this data.
     */
    create: XOR<SignalSessionCreateInput, SignalSessionUncheckedCreateInput>
    /**
     * In case the SignalSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalSessionUpdateInput, SignalSessionUncheckedUpdateInput>
  }

  /**
   * SignalSession delete
   */
  export type SignalSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
    /**
     * Filter which SignalSession to delete.
     */
    where: SignalSessionWhereUniqueInput
  }

  /**
   * SignalSession deleteMany
   */
  export type SignalSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalSessions to delete
     */
    where?: SignalSessionWhereInput
  }

  /**
   * SignalSession without action
   */
  export type SignalSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalSession
     */
    select?: SignalSessionSelect<ExtArgs> | null
  }


  /**
   * Model SenderKey
   */

  export type AggregateSenderKey = {
    _count: SenderKeyCountAggregateOutputType | null
    _avg: SenderKeyAvgAggregateOutputType | null
    _sum: SenderKeySumAggregateOutputType | null
    _min: SenderKeyMinAggregateOutputType | null
    _max: SenderKeyMaxAggregateOutputType | null
  }

  export type SenderKeyAvgAggregateOutputType = {
    deviceId: number | null
  }

  export type SenderKeySumAggregateOutputType = {
    deviceId: number | null
  }

  export type SenderKeyMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    deviceId: number | null
    keyData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SenderKeyMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    deviceId: number | null
    keyData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SenderKeyCountAggregateOutputType = {
    id: number
    groupId: number
    senderId: number
    deviceId: number
    keyData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SenderKeyAvgAggregateInputType = {
    deviceId?: true
  }

  export type SenderKeySumAggregateInputType = {
    deviceId?: true
  }

  export type SenderKeyMinAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    deviceId?: true
    keyData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SenderKeyMaxAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    deviceId?: true
    keyData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SenderKeyCountAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    deviceId?: true
    keyData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SenderKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SenderKey to aggregate.
     */
    where?: SenderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SenderKeys to fetch.
     */
    orderBy?: SenderKeyOrderByWithRelationInput | SenderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SenderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SenderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SenderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SenderKeys
    **/
    _count?: true | SenderKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SenderKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SenderKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SenderKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SenderKeyMaxAggregateInputType
  }

  export type GetSenderKeyAggregateType<T extends SenderKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateSenderKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSenderKey[P]>
      : GetScalarType<T[P], AggregateSenderKey[P]>
  }




  export type SenderKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SenderKeyWhereInput
    orderBy?: SenderKeyOrderByWithAggregationInput | SenderKeyOrderByWithAggregationInput[]
    by: SenderKeyScalarFieldEnum[] | SenderKeyScalarFieldEnum
    having?: SenderKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SenderKeyCountAggregateInputType | true
    _avg?: SenderKeyAvgAggregateInputType
    _sum?: SenderKeySumAggregateInputType
    _min?: SenderKeyMinAggregateInputType
    _max?: SenderKeyMaxAggregateInputType
  }

  export type SenderKeyGroupByOutputType = {
    id: string
    groupId: string
    senderId: string
    deviceId: number
    keyData: string
    createdAt: Date
    updatedAt: Date
    _count: SenderKeyCountAggregateOutputType | null
    _avg: SenderKeyAvgAggregateOutputType | null
    _sum: SenderKeySumAggregateOutputType | null
    _min: SenderKeyMinAggregateOutputType | null
    _max: SenderKeyMaxAggregateOutputType | null
  }

  type GetSenderKeyGroupByPayload<T extends SenderKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SenderKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SenderKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SenderKeyGroupByOutputType[P]>
            : GetScalarType<T[P], SenderKeyGroupByOutputType[P]>
        }
      >
    >


  export type SenderKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    deviceId?: boolean
    keyData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["senderKey"]>

  export type SenderKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    deviceId?: boolean
    keyData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["senderKey"]>

  export type SenderKeySelectScalar = {
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    deviceId?: boolean
    keyData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SenderKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SenderKey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      senderId: string
      deviceId: number
      keyData: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["senderKey"]>
    composites: {}
  }

  type SenderKeyGetPayload<S extends boolean | null | undefined | SenderKeyDefaultArgs> = $Result.GetResult<Prisma.$SenderKeyPayload, S>

  type SenderKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SenderKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SenderKeyCountAggregateInputType | true
    }

  export interface SenderKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SenderKey'], meta: { name: 'SenderKey' } }
    /**
     * Find zero or one SenderKey that matches the filter.
     * @param {SenderKeyFindUniqueArgs} args - Arguments to find a SenderKey
     * @example
     * // Get one SenderKey
     * const senderKey = await prisma.senderKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SenderKeyFindUniqueArgs>(args: SelectSubset<T, SenderKeyFindUniqueArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SenderKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SenderKeyFindUniqueOrThrowArgs} args - Arguments to find a SenderKey
     * @example
     * // Get one SenderKey
     * const senderKey = await prisma.senderKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SenderKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, SenderKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SenderKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyFindFirstArgs} args - Arguments to find a SenderKey
     * @example
     * // Get one SenderKey
     * const senderKey = await prisma.senderKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SenderKeyFindFirstArgs>(args?: SelectSubset<T, SenderKeyFindFirstArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SenderKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyFindFirstOrThrowArgs} args - Arguments to find a SenderKey
     * @example
     * // Get one SenderKey
     * const senderKey = await prisma.senderKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SenderKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, SenderKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SenderKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SenderKeys
     * const senderKeys = await prisma.senderKey.findMany()
     * 
     * // Get first 10 SenderKeys
     * const senderKeys = await prisma.senderKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const senderKeyWithIdOnly = await prisma.senderKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SenderKeyFindManyArgs>(args?: SelectSubset<T, SenderKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SenderKey.
     * @param {SenderKeyCreateArgs} args - Arguments to create a SenderKey.
     * @example
     * // Create one SenderKey
     * const SenderKey = await prisma.senderKey.create({
     *   data: {
     *     // ... data to create a SenderKey
     *   }
     * })
     * 
     */
    create<T extends SenderKeyCreateArgs>(args: SelectSubset<T, SenderKeyCreateArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SenderKeys.
     * @param {SenderKeyCreateManyArgs} args - Arguments to create many SenderKeys.
     * @example
     * // Create many SenderKeys
     * const senderKey = await prisma.senderKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SenderKeyCreateManyArgs>(args?: SelectSubset<T, SenderKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SenderKeys and returns the data saved in the database.
     * @param {SenderKeyCreateManyAndReturnArgs} args - Arguments to create many SenderKeys.
     * @example
     * // Create many SenderKeys
     * const senderKey = await prisma.senderKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SenderKeys and only return the `id`
     * const senderKeyWithIdOnly = await prisma.senderKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SenderKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, SenderKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SenderKey.
     * @param {SenderKeyDeleteArgs} args - Arguments to delete one SenderKey.
     * @example
     * // Delete one SenderKey
     * const SenderKey = await prisma.senderKey.delete({
     *   where: {
     *     // ... filter to delete one SenderKey
     *   }
     * })
     * 
     */
    delete<T extends SenderKeyDeleteArgs>(args: SelectSubset<T, SenderKeyDeleteArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SenderKey.
     * @param {SenderKeyUpdateArgs} args - Arguments to update one SenderKey.
     * @example
     * // Update one SenderKey
     * const senderKey = await prisma.senderKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SenderKeyUpdateArgs>(args: SelectSubset<T, SenderKeyUpdateArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SenderKeys.
     * @param {SenderKeyDeleteManyArgs} args - Arguments to filter SenderKeys to delete.
     * @example
     * // Delete a few SenderKeys
     * const { count } = await prisma.senderKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SenderKeyDeleteManyArgs>(args?: SelectSubset<T, SenderKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SenderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SenderKeys
     * const senderKey = await prisma.senderKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SenderKeyUpdateManyArgs>(args: SelectSubset<T, SenderKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SenderKey.
     * @param {SenderKeyUpsertArgs} args - Arguments to update or create a SenderKey.
     * @example
     * // Update or create a SenderKey
     * const senderKey = await prisma.senderKey.upsert({
     *   create: {
     *     // ... data to create a SenderKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SenderKey we want to update
     *   }
     * })
     */
    upsert<T extends SenderKeyUpsertArgs>(args: SelectSubset<T, SenderKeyUpsertArgs<ExtArgs>>): Prisma__SenderKeyClient<$Result.GetResult<Prisma.$SenderKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SenderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyCountArgs} args - Arguments to filter SenderKeys to count.
     * @example
     * // Count the number of SenderKeys
     * const count = await prisma.senderKey.count({
     *   where: {
     *     // ... the filter for the SenderKeys we want to count
     *   }
     * })
    **/
    count<T extends SenderKeyCountArgs>(
      args?: Subset<T, SenderKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SenderKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SenderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SenderKeyAggregateArgs>(args: Subset<T, SenderKeyAggregateArgs>): Prisma.PrismaPromise<GetSenderKeyAggregateType<T>>

    /**
     * Group by SenderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SenderKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SenderKeyGroupByArgs['orderBy'] }
        : { orderBy?: SenderKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SenderKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSenderKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SenderKey model
   */
  readonly fields: SenderKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SenderKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SenderKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SenderKey model
   */ 
  interface SenderKeyFieldRefs {
    readonly id: FieldRef<"SenderKey", 'String'>
    readonly groupId: FieldRef<"SenderKey", 'String'>
    readonly senderId: FieldRef<"SenderKey", 'String'>
    readonly deviceId: FieldRef<"SenderKey", 'Int'>
    readonly keyData: FieldRef<"SenderKey", 'String'>
    readonly createdAt: FieldRef<"SenderKey", 'DateTime'>
    readonly updatedAt: FieldRef<"SenderKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SenderKey findUnique
   */
  export type SenderKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter, which SenderKey to fetch.
     */
    where: SenderKeyWhereUniqueInput
  }

  /**
   * SenderKey findUniqueOrThrow
   */
  export type SenderKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter, which SenderKey to fetch.
     */
    where: SenderKeyWhereUniqueInput
  }

  /**
   * SenderKey findFirst
   */
  export type SenderKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter, which SenderKey to fetch.
     */
    where?: SenderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SenderKeys to fetch.
     */
    orderBy?: SenderKeyOrderByWithRelationInput | SenderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SenderKeys.
     */
    cursor?: SenderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SenderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SenderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SenderKeys.
     */
    distinct?: SenderKeyScalarFieldEnum | SenderKeyScalarFieldEnum[]
  }

  /**
   * SenderKey findFirstOrThrow
   */
  export type SenderKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter, which SenderKey to fetch.
     */
    where?: SenderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SenderKeys to fetch.
     */
    orderBy?: SenderKeyOrderByWithRelationInput | SenderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SenderKeys.
     */
    cursor?: SenderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SenderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SenderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SenderKeys.
     */
    distinct?: SenderKeyScalarFieldEnum | SenderKeyScalarFieldEnum[]
  }

  /**
   * SenderKey findMany
   */
  export type SenderKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter, which SenderKeys to fetch.
     */
    where?: SenderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SenderKeys to fetch.
     */
    orderBy?: SenderKeyOrderByWithRelationInput | SenderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SenderKeys.
     */
    cursor?: SenderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SenderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SenderKeys.
     */
    skip?: number
    distinct?: SenderKeyScalarFieldEnum | SenderKeyScalarFieldEnum[]
  }

  /**
   * SenderKey create
   */
  export type SenderKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * The data needed to create a SenderKey.
     */
    data: XOR<SenderKeyCreateInput, SenderKeyUncheckedCreateInput>
  }

  /**
   * SenderKey createMany
   */
  export type SenderKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SenderKeys.
     */
    data: SenderKeyCreateManyInput | SenderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SenderKey createManyAndReturn
   */
  export type SenderKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SenderKeys.
     */
    data: SenderKeyCreateManyInput | SenderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SenderKey update
   */
  export type SenderKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * The data needed to update a SenderKey.
     */
    data: XOR<SenderKeyUpdateInput, SenderKeyUncheckedUpdateInput>
    /**
     * Choose, which SenderKey to update.
     */
    where: SenderKeyWhereUniqueInput
  }

  /**
   * SenderKey updateMany
   */
  export type SenderKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SenderKeys.
     */
    data: XOR<SenderKeyUpdateManyMutationInput, SenderKeyUncheckedUpdateManyInput>
    /**
     * Filter which SenderKeys to update
     */
    where?: SenderKeyWhereInput
  }

  /**
   * SenderKey upsert
   */
  export type SenderKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * The filter to search for the SenderKey to update in case it exists.
     */
    where: SenderKeyWhereUniqueInput
    /**
     * In case the SenderKey found by the `where` argument doesn't exist, create a new SenderKey with this data.
     */
    create: XOR<SenderKeyCreateInput, SenderKeyUncheckedCreateInput>
    /**
     * In case the SenderKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SenderKeyUpdateInput, SenderKeyUncheckedUpdateInput>
  }

  /**
   * SenderKey delete
   */
  export type SenderKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
    /**
     * Filter which SenderKey to delete.
     */
    where: SenderKeyWhereUniqueInput
  }

  /**
   * SenderKey deleteMany
   */
  export type SenderKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SenderKeys to delete
     */
    where?: SenderKeyWhereInput
  }

  /**
   * SenderKey without action
   */
  export type SenderKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderKey
     */
    select?: SenderKeySelect<ExtArgs> | null
  }


  /**
   * Model SignalMessageMetadata
   */

  export type AggregateSignalMessageMetadata = {
    _count: SignalMessageMetadataCountAggregateOutputType | null
    _avg: SignalMessageMetadataAvgAggregateOutputType | null
    _sum: SignalMessageMetadataSumAggregateOutputType | null
    _min: SignalMessageMetadataMinAggregateOutputType | null
    _max: SignalMessageMetadataMaxAggregateOutputType | null
  }

  export type SignalMessageMetadataAvgAggregateOutputType = {
    cipherType: number | null
    deviceId: number | null
  }

  export type SignalMessageMetadataSumAggregateOutputType = {
    cipherType: number | null
    deviceId: number | null
  }

  export type SignalMessageMetadataMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    cipherType: number | null
    deviceId: number | null
    senderKeyDistribution: string | null
  }

  export type SignalMessageMetadataMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    cipherType: number | null
    deviceId: number | null
    senderKeyDistribution: string | null
  }

  export type SignalMessageMetadataCountAggregateOutputType = {
    id: number
    messageId: number
    cipherType: number
    deviceId: number
    senderKeyDistribution: number
    _all: number
  }


  export type SignalMessageMetadataAvgAggregateInputType = {
    cipherType?: true
    deviceId?: true
  }

  export type SignalMessageMetadataSumAggregateInputType = {
    cipherType?: true
    deviceId?: true
  }

  export type SignalMessageMetadataMinAggregateInputType = {
    id?: true
    messageId?: true
    cipherType?: true
    deviceId?: true
    senderKeyDistribution?: true
  }

  export type SignalMessageMetadataMaxAggregateInputType = {
    id?: true
    messageId?: true
    cipherType?: true
    deviceId?: true
    senderKeyDistribution?: true
  }

  export type SignalMessageMetadataCountAggregateInputType = {
    id?: true
    messageId?: true
    cipherType?: true
    deviceId?: true
    senderKeyDistribution?: true
    _all?: true
  }

  export type SignalMessageMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalMessageMetadata to aggregate.
     */
    where?: SignalMessageMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalMessageMetadata to fetch.
     */
    orderBy?: SignalMessageMetadataOrderByWithRelationInput | SignalMessageMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalMessageMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalMessageMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalMessageMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignalMessageMetadata
    **/
    _count?: true | SignalMessageMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalMessageMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalMessageMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalMessageMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalMessageMetadataMaxAggregateInputType
  }

  export type GetSignalMessageMetadataAggregateType<T extends SignalMessageMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateSignalMessageMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignalMessageMetadata[P]>
      : GetScalarType<T[P], AggregateSignalMessageMetadata[P]>
  }




  export type SignalMessageMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalMessageMetadataWhereInput
    orderBy?: SignalMessageMetadataOrderByWithAggregationInput | SignalMessageMetadataOrderByWithAggregationInput[]
    by: SignalMessageMetadataScalarFieldEnum[] | SignalMessageMetadataScalarFieldEnum
    having?: SignalMessageMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalMessageMetadataCountAggregateInputType | true
    _avg?: SignalMessageMetadataAvgAggregateInputType
    _sum?: SignalMessageMetadataSumAggregateInputType
    _min?: SignalMessageMetadataMinAggregateInputType
    _max?: SignalMessageMetadataMaxAggregateInputType
  }

  export type SignalMessageMetadataGroupByOutputType = {
    id: string
    messageId: string
    cipherType: number
    deviceId: number
    senderKeyDistribution: string | null
    _count: SignalMessageMetadataCountAggregateOutputType | null
    _avg: SignalMessageMetadataAvgAggregateOutputType | null
    _sum: SignalMessageMetadataSumAggregateOutputType | null
    _min: SignalMessageMetadataMinAggregateOutputType | null
    _max: SignalMessageMetadataMaxAggregateOutputType | null
  }

  type GetSignalMessageMetadataGroupByPayload<T extends SignalMessageMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalMessageMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalMessageMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalMessageMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], SignalMessageMetadataGroupByOutputType[P]>
        }
      >
    >


  export type SignalMessageMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    cipherType?: boolean
    deviceId?: boolean
    senderKeyDistribution?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signalMessageMetadata"]>

  export type SignalMessageMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    cipherType?: boolean
    deviceId?: boolean
    senderKeyDistribution?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signalMessageMetadata"]>

  export type SignalMessageMetadataSelectScalar = {
    id?: boolean
    messageId?: boolean
    cipherType?: boolean
    deviceId?: boolean
    senderKeyDistribution?: boolean
  }

  export type SignalMessageMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type SignalMessageMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $SignalMessageMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SignalMessageMetadata"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      cipherType: number
      deviceId: number
      senderKeyDistribution: string | null
    }, ExtArgs["result"]["signalMessageMetadata"]>
    composites: {}
  }

  type SignalMessageMetadataGetPayload<S extends boolean | null | undefined | SignalMessageMetadataDefaultArgs> = $Result.GetResult<Prisma.$SignalMessageMetadataPayload, S>

  type SignalMessageMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignalMessageMetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignalMessageMetadataCountAggregateInputType | true
    }

  export interface SignalMessageMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SignalMessageMetadata'], meta: { name: 'SignalMessageMetadata' } }
    /**
     * Find zero or one SignalMessageMetadata that matches the filter.
     * @param {SignalMessageMetadataFindUniqueArgs} args - Arguments to find a SignalMessageMetadata
     * @example
     * // Get one SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalMessageMetadataFindUniqueArgs>(args: SelectSubset<T, SignalMessageMetadataFindUniqueArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SignalMessageMetadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignalMessageMetadataFindUniqueOrThrowArgs} args - Arguments to find a SignalMessageMetadata
     * @example
     * // Get one SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalMessageMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalMessageMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SignalMessageMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataFindFirstArgs} args - Arguments to find a SignalMessageMetadata
     * @example
     * // Get one SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalMessageMetadataFindFirstArgs>(args?: SelectSubset<T, SignalMessageMetadataFindFirstArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SignalMessageMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataFindFirstOrThrowArgs} args - Arguments to find a SignalMessageMetadata
     * @example
     * // Get one SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalMessageMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalMessageMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SignalMessageMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findMany()
     * 
     * // Get first 10 SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalMessageMetadataWithIdOnly = await prisma.signalMessageMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalMessageMetadataFindManyArgs>(args?: SelectSubset<T, SignalMessageMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SignalMessageMetadata.
     * @param {SignalMessageMetadataCreateArgs} args - Arguments to create a SignalMessageMetadata.
     * @example
     * // Create one SignalMessageMetadata
     * const SignalMessageMetadata = await prisma.signalMessageMetadata.create({
     *   data: {
     *     // ... data to create a SignalMessageMetadata
     *   }
     * })
     * 
     */
    create<T extends SignalMessageMetadataCreateArgs>(args: SelectSubset<T, SignalMessageMetadataCreateArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SignalMessageMetadata.
     * @param {SignalMessageMetadataCreateManyArgs} args - Arguments to create many SignalMessageMetadata.
     * @example
     * // Create many SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalMessageMetadataCreateManyArgs>(args?: SelectSubset<T, SignalMessageMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SignalMessageMetadata and returns the data saved in the database.
     * @param {SignalMessageMetadataCreateManyAndReturnArgs} args - Arguments to create many SignalMessageMetadata.
     * @example
     * // Create many SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SignalMessageMetadata and only return the `id`
     * const signalMessageMetadataWithIdOnly = await prisma.signalMessageMetadata.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalMessageMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalMessageMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SignalMessageMetadata.
     * @param {SignalMessageMetadataDeleteArgs} args - Arguments to delete one SignalMessageMetadata.
     * @example
     * // Delete one SignalMessageMetadata
     * const SignalMessageMetadata = await prisma.signalMessageMetadata.delete({
     *   where: {
     *     // ... filter to delete one SignalMessageMetadata
     *   }
     * })
     * 
     */
    delete<T extends SignalMessageMetadataDeleteArgs>(args: SelectSubset<T, SignalMessageMetadataDeleteArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SignalMessageMetadata.
     * @param {SignalMessageMetadataUpdateArgs} args - Arguments to update one SignalMessageMetadata.
     * @example
     * // Update one SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalMessageMetadataUpdateArgs>(args: SelectSubset<T, SignalMessageMetadataUpdateArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SignalMessageMetadata.
     * @param {SignalMessageMetadataDeleteManyArgs} args - Arguments to filter SignalMessageMetadata to delete.
     * @example
     * // Delete a few SignalMessageMetadata
     * const { count } = await prisma.signalMessageMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalMessageMetadataDeleteManyArgs>(args?: SelectSubset<T, SignalMessageMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignalMessageMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalMessageMetadataUpdateManyArgs>(args: SelectSubset<T, SignalMessageMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SignalMessageMetadata.
     * @param {SignalMessageMetadataUpsertArgs} args - Arguments to update or create a SignalMessageMetadata.
     * @example
     * // Update or create a SignalMessageMetadata
     * const signalMessageMetadata = await prisma.signalMessageMetadata.upsert({
     *   create: {
     *     // ... data to create a SignalMessageMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignalMessageMetadata we want to update
     *   }
     * })
     */
    upsert<T extends SignalMessageMetadataUpsertArgs>(args: SelectSubset<T, SignalMessageMetadataUpsertArgs<ExtArgs>>): Prisma__SignalMessageMetadataClient<$Result.GetResult<Prisma.$SignalMessageMetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SignalMessageMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataCountArgs} args - Arguments to filter SignalMessageMetadata to count.
     * @example
     * // Count the number of SignalMessageMetadata
     * const count = await prisma.signalMessageMetadata.count({
     *   where: {
     *     // ... the filter for the SignalMessageMetadata we want to count
     *   }
     * })
    **/
    count<T extends SignalMessageMetadataCountArgs>(
      args?: Subset<T, SignalMessageMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalMessageMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignalMessageMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalMessageMetadataAggregateArgs>(args: Subset<T, SignalMessageMetadataAggregateArgs>): Prisma.PrismaPromise<GetSignalMessageMetadataAggregateType<T>>

    /**
     * Group by SignalMessageMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalMessageMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalMessageMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalMessageMetadataGroupByArgs['orderBy'] }
        : { orderBy?: SignalMessageMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalMessageMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalMessageMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SignalMessageMetadata model
   */
  readonly fields: SignalMessageMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignalMessageMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalMessageMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SignalMessageMetadata model
   */ 
  interface SignalMessageMetadataFieldRefs {
    readonly id: FieldRef<"SignalMessageMetadata", 'String'>
    readonly messageId: FieldRef<"SignalMessageMetadata", 'String'>
    readonly cipherType: FieldRef<"SignalMessageMetadata", 'Int'>
    readonly deviceId: FieldRef<"SignalMessageMetadata", 'Int'>
    readonly senderKeyDistribution: FieldRef<"SignalMessageMetadata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SignalMessageMetadata findUnique
   */
  export type SignalMessageMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter, which SignalMessageMetadata to fetch.
     */
    where: SignalMessageMetadataWhereUniqueInput
  }

  /**
   * SignalMessageMetadata findUniqueOrThrow
   */
  export type SignalMessageMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter, which SignalMessageMetadata to fetch.
     */
    where: SignalMessageMetadataWhereUniqueInput
  }

  /**
   * SignalMessageMetadata findFirst
   */
  export type SignalMessageMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter, which SignalMessageMetadata to fetch.
     */
    where?: SignalMessageMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalMessageMetadata to fetch.
     */
    orderBy?: SignalMessageMetadataOrderByWithRelationInput | SignalMessageMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalMessageMetadata.
     */
    cursor?: SignalMessageMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalMessageMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalMessageMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalMessageMetadata.
     */
    distinct?: SignalMessageMetadataScalarFieldEnum | SignalMessageMetadataScalarFieldEnum[]
  }

  /**
   * SignalMessageMetadata findFirstOrThrow
   */
  export type SignalMessageMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter, which SignalMessageMetadata to fetch.
     */
    where?: SignalMessageMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalMessageMetadata to fetch.
     */
    orderBy?: SignalMessageMetadataOrderByWithRelationInput | SignalMessageMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalMessageMetadata.
     */
    cursor?: SignalMessageMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalMessageMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalMessageMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalMessageMetadata.
     */
    distinct?: SignalMessageMetadataScalarFieldEnum | SignalMessageMetadataScalarFieldEnum[]
  }

  /**
   * SignalMessageMetadata findMany
   */
  export type SignalMessageMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter, which SignalMessageMetadata to fetch.
     */
    where?: SignalMessageMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalMessageMetadata to fetch.
     */
    orderBy?: SignalMessageMetadataOrderByWithRelationInput | SignalMessageMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignalMessageMetadata.
     */
    cursor?: SignalMessageMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalMessageMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalMessageMetadata.
     */
    skip?: number
    distinct?: SignalMessageMetadataScalarFieldEnum | SignalMessageMetadataScalarFieldEnum[]
  }

  /**
   * SignalMessageMetadata create
   */
  export type SignalMessageMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a SignalMessageMetadata.
     */
    data: XOR<SignalMessageMetadataCreateInput, SignalMessageMetadataUncheckedCreateInput>
  }

  /**
   * SignalMessageMetadata createMany
   */
  export type SignalMessageMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SignalMessageMetadata.
     */
    data: SignalMessageMetadataCreateManyInput | SignalMessageMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignalMessageMetadata createManyAndReturn
   */
  export type SignalMessageMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SignalMessageMetadata.
     */
    data: SignalMessageMetadataCreateManyInput | SignalMessageMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SignalMessageMetadata update
   */
  export type SignalMessageMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a SignalMessageMetadata.
     */
    data: XOR<SignalMessageMetadataUpdateInput, SignalMessageMetadataUncheckedUpdateInput>
    /**
     * Choose, which SignalMessageMetadata to update.
     */
    where: SignalMessageMetadataWhereUniqueInput
  }

  /**
   * SignalMessageMetadata updateMany
   */
  export type SignalMessageMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SignalMessageMetadata.
     */
    data: XOR<SignalMessageMetadataUpdateManyMutationInput, SignalMessageMetadataUncheckedUpdateManyInput>
    /**
     * Filter which SignalMessageMetadata to update
     */
    where?: SignalMessageMetadataWhereInput
  }

  /**
   * SignalMessageMetadata upsert
   */
  export type SignalMessageMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the SignalMessageMetadata to update in case it exists.
     */
    where: SignalMessageMetadataWhereUniqueInput
    /**
     * In case the SignalMessageMetadata found by the `where` argument doesn't exist, create a new SignalMessageMetadata with this data.
     */
    create: XOR<SignalMessageMetadataCreateInput, SignalMessageMetadataUncheckedCreateInput>
    /**
     * In case the SignalMessageMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalMessageMetadataUpdateInput, SignalMessageMetadataUncheckedUpdateInput>
  }

  /**
   * SignalMessageMetadata delete
   */
  export type SignalMessageMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
    /**
     * Filter which SignalMessageMetadata to delete.
     */
    where: SignalMessageMetadataWhereUniqueInput
  }

  /**
   * SignalMessageMetadata deleteMany
   */
  export type SignalMessageMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignalMessageMetadata to delete
     */
    where?: SignalMessageMetadataWhereInput
  }

  /**
   * SignalMessageMetadata without action
   */
  export type SignalMessageMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalMessageMetadata
     */
    select?: SignalMessageMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalMessageMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactUserId: string | null
    customName: string | null
    isBlocked: boolean | null
    isMuted: boolean | null
    addedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactUserId: string | null
    customName: string | null
    isBlocked: boolean | null
    isMuted: boolean | null
    addedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    userId: number
    contactUserId: number
    customName: number
    isBlocked: number
    isMuted: number
    addedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    userId?: true
    contactUserId?: true
    customName?: true
    isBlocked?: true
    isMuted?: true
    addedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    userId?: true
    contactUserId?: true
    customName?: true
    isBlocked?: true
    isMuted?: true
    addedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    userId?: true
    contactUserId?: true
    customName?: true
    isBlocked?: true
    isMuted?: true
    addedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    userId: string
    contactUserId: string
    customName: string | null
    isBlocked: boolean
    isMuted: boolean
    addedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactUserId?: boolean
    customName?: boolean
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactUserId?: boolean
    customName?: boolean
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    userId?: boolean
    contactUserId?: boolean
    customName?: boolean
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contactUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactUserId: string
      customName: string | null
      isBlocked: boolean
      isMuted: boolean
      addedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contactUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly contactUserId: FieldRef<"Contact", 'String'>
    readonly customName: FieldRef<"Contact", 'String'>
    readonly isBlocked: FieldRef<"Contact", 'Boolean'>
    readonly isMuted: FieldRef<"Contact", 'Boolean'>
    readonly addedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model DeletedMessage
   */

  export type AggregateDeletedMessage = {
    _count: DeletedMessageCountAggregateOutputType | null
    _min: DeletedMessageMinAggregateOutputType | null
    _max: DeletedMessageMaxAggregateOutputType | null
  }

  export type DeletedMessageMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    deletedAt: Date | null
  }

  export type DeletedMessageMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    deletedAt: Date | null
  }

  export type DeletedMessageCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    deletedAt: number
    _all: number
  }


  export type DeletedMessageMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deletedAt?: true
  }

  export type DeletedMessageMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deletedAt?: true
  }

  export type DeletedMessageCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deletedAt?: true
    _all?: true
  }

  export type DeletedMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedMessage to aggregate.
     */
    where?: DeletedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessages to fetch.
     */
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeletedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedMessages
    **/
    _count?: true | DeletedMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeletedMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeletedMessageMaxAggregateInputType
  }

  export type GetDeletedMessageAggregateType<T extends DeletedMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDeletedMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedMessage[P]>
      : GetScalarType<T[P], AggregateDeletedMessage[P]>
  }




  export type DeletedMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletedMessageWhereInput
    orderBy?: DeletedMessageOrderByWithAggregationInput | DeletedMessageOrderByWithAggregationInput[]
    by: DeletedMessageScalarFieldEnum[] | DeletedMessageScalarFieldEnum
    having?: DeletedMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeletedMessageCountAggregateInputType | true
    _min?: DeletedMessageMinAggregateInputType
    _max?: DeletedMessageMaxAggregateInputType
  }

  export type DeletedMessageGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    deletedAt: Date
    _count: DeletedMessageCountAggregateOutputType | null
    _min: DeletedMessageMinAggregateOutputType | null
    _max: DeletedMessageMaxAggregateOutputType | null
  }

  type GetDeletedMessageGroupByPayload<T extends DeletedMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeletedMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeletedMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeletedMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DeletedMessageGroupByOutputType[P]>
        }
      >
    >


  export type DeletedMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletedMessage"]>

  export type DeletedMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletedMessage"]>

  export type DeletedMessageSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    deletedAt?: boolean
  }

  export type DeletedMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeletedMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeletedMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeletedMessage"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      deletedAt: Date
    }, ExtArgs["result"]["deletedMessage"]>
    composites: {}
  }

  type DeletedMessageGetPayload<S extends boolean | null | undefined | DeletedMessageDefaultArgs> = $Result.GetResult<Prisma.$DeletedMessagePayload, S>

  type DeletedMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeletedMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeletedMessageCountAggregateInputType | true
    }

  export interface DeletedMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeletedMessage'], meta: { name: 'DeletedMessage' } }
    /**
     * Find zero or one DeletedMessage that matches the filter.
     * @param {DeletedMessageFindUniqueArgs} args - Arguments to find a DeletedMessage
     * @example
     * // Get one DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeletedMessageFindUniqueArgs>(args: SelectSubset<T, DeletedMessageFindUniqueArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeletedMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeletedMessageFindUniqueOrThrowArgs} args - Arguments to find a DeletedMessage
     * @example
     * // Get one DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeletedMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DeletedMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeletedMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageFindFirstArgs} args - Arguments to find a DeletedMessage
     * @example
     * // Get one DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeletedMessageFindFirstArgs>(args?: SelectSubset<T, DeletedMessageFindFirstArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeletedMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageFindFirstOrThrowArgs} args - Arguments to find a DeletedMessage
     * @example
     * // Get one DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeletedMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DeletedMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeletedMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedMessages
     * const deletedMessages = await prisma.deletedMessage.findMany()
     * 
     * // Get first 10 DeletedMessages
     * const deletedMessages = await prisma.deletedMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletedMessageWithIdOnly = await prisma.deletedMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeletedMessageFindManyArgs>(args?: SelectSubset<T, DeletedMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeletedMessage.
     * @param {DeletedMessageCreateArgs} args - Arguments to create a DeletedMessage.
     * @example
     * // Create one DeletedMessage
     * const DeletedMessage = await prisma.deletedMessage.create({
     *   data: {
     *     // ... data to create a DeletedMessage
     *   }
     * })
     * 
     */
    create<T extends DeletedMessageCreateArgs>(args: SelectSubset<T, DeletedMessageCreateArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeletedMessages.
     * @param {DeletedMessageCreateManyArgs} args - Arguments to create many DeletedMessages.
     * @example
     * // Create many DeletedMessages
     * const deletedMessage = await prisma.deletedMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeletedMessageCreateManyArgs>(args?: SelectSubset<T, DeletedMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeletedMessages and returns the data saved in the database.
     * @param {DeletedMessageCreateManyAndReturnArgs} args - Arguments to create many DeletedMessages.
     * @example
     * // Create many DeletedMessages
     * const deletedMessage = await prisma.deletedMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeletedMessages and only return the `id`
     * const deletedMessageWithIdOnly = await prisma.deletedMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeletedMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DeletedMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeletedMessage.
     * @param {DeletedMessageDeleteArgs} args - Arguments to delete one DeletedMessage.
     * @example
     * // Delete one DeletedMessage
     * const DeletedMessage = await prisma.deletedMessage.delete({
     *   where: {
     *     // ... filter to delete one DeletedMessage
     *   }
     * })
     * 
     */
    delete<T extends DeletedMessageDeleteArgs>(args: SelectSubset<T, DeletedMessageDeleteArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeletedMessage.
     * @param {DeletedMessageUpdateArgs} args - Arguments to update one DeletedMessage.
     * @example
     * // Update one DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeletedMessageUpdateArgs>(args: SelectSubset<T, DeletedMessageUpdateArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeletedMessages.
     * @param {DeletedMessageDeleteManyArgs} args - Arguments to filter DeletedMessages to delete.
     * @example
     * // Delete a few DeletedMessages
     * const { count } = await prisma.deletedMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeletedMessageDeleteManyArgs>(args?: SelectSubset<T, DeletedMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeletedMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedMessages
     * const deletedMessage = await prisma.deletedMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeletedMessageUpdateManyArgs>(args: SelectSubset<T, DeletedMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeletedMessage.
     * @param {DeletedMessageUpsertArgs} args - Arguments to update or create a DeletedMessage.
     * @example
     * // Update or create a DeletedMessage
     * const deletedMessage = await prisma.deletedMessage.upsert({
     *   create: {
     *     // ... data to create a DeletedMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedMessage we want to update
     *   }
     * })
     */
    upsert<T extends DeletedMessageUpsertArgs>(args: SelectSubset<T, DeletedMessageUpsertArgs<ExtArgs>>): Prisma__DeletedMessageClient<$Result.GetResult<Prisma.$DeletedMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeletedMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageCountArgs} args - Arguments to filter DeletedMessages to count.
     * @example
     * // Count the number of DeletedMessages
     * const count = await prisma.deletedMessage.count({
     *   where: {
     *     // ... the filter for the DeletedMessages we want to count
     *   }
     * })
    **/
    count<T extends DeletedMessageCountArgs>(
      args?: Subset<T, DeletedMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedMessageAggregateArgs>(args: Subset<T, DeletedMessageAggregateArgs>): Prisma.PrismaPromise<GetDeletedMessageAggregateType<T>>

    /**
     * Group by DeletedMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeletedMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeletedMessageGroupByArgs['orderBy'] }
        : { orderBy?: DeletedMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeletedMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeletedMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeletedMessage model
   */
  readonly fields: DeletedMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeletedMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeletedMessage model
   */ 
  interface DeletedMessageFieldRefs {
    readonly id: FieldRef<"DeletedMessage", 'String'>
    readonly messageId: FieldRef<"DeletedMessage", 'String'>
    readonly userId: FieldRef<"DeletedMessage", 'String'>
    readonly deletedAt: FieldRef<"DeletedMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeletedMessage findUnique
   */
  export type DeletedMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter, which DeletedMessage to fetch.
     */
    where: DeletedMessageWhereUniqueInput
  }

  /**
   * DeletedMessage findUniqueOrThrow
   */
  export type DeletedMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter, which DeletedMessage to fetch.
     */
    where: DeletedMessageWhereUniqueInput
  }

  /**
   * DeletedMessage findFirst
   */
  export type DeletedMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter, which DeletedMessage to fetch.
     */
    where?: DeletedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessages to fetch.
     */
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedMessages.
     */
    cursor?: DeletedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedMessages.
     */
    distinct?: DeletedMessageScalarFieldEnum | DeletedMessageScalarFieldEnum[]
  }

  /**
   * DeletedMessage findFirstOrThrow
   */
  export type DeletedMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter, which DeletedMessage to fetch.
     */
    where?: DeletedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessages to fetch.
     */
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedMessages.
     */
    cursor?: DeletedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedMessages.
     */
    distinct?: DeletedMessageScalarFieldEnum | DeletedMessageScalarFieldEnum[]
  }

  /**
   * DeletedMessage findMany
   */
  export type DeletedMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter, which DeletedMessages to fetch.
     */
    where?: DeletedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessages to fetch.
     */
    orderBy?: DeletedMessageOrderByWithRelationInput | DeletedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedMessages.
     */
    cursor?: DeletedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessages.
     */
    skip?: number
    distinct?: DeletedMessageScalarFieldEnum | DeletedMessageScalarFieldEnum[]
  }

  /**
   * DeletedMessage create
   */
  export type DeletedMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DeletedMessage.
     */
    data: XOR<DeletedMessageCreateInput, DeletedMessageUncheckedCreateInput>
  }

  /**
   * DeletedMessage createMany
   */
  export type DeletedMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeletedMessages.
     */
    data: DeletedMessageCreateManyInput | DeletedMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeletedMessage createManyAndReturn
   */
  export type DeletedMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeletedMessages.
     */
    data: DeletedMessageCreateManyInput | DeletedMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeletedMessage update
   */
  export type DeletedMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DeletedMessage.
     */
    data: XOR<DeletedMessageUpdateInput, DeletedMessageUncheckedUpdateInput>
    /**
     * Choose, which DeletedMessage to update.
     */
    where: DeletedMessageWhereUniqueInput
  }

  /**
   * DeletedMessage updateMany
   */
  export type DeletedMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeletedMessages.
     */
    data: XOR<DeletedMessageUpdateManyMutationInput, DeletedMessageUncheckedUpdateManyInput>
    /**
     * Filter which DeletedMessages to update
     */
    where?: DeletedMessageWhereInput
  }

  /**
   * DeletedMessage upsert
   */
  export type DeletedMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DeletedMessage to update in case it exists.
     */
    where: DeletedMessageWhereUniqueInput
    /**
     * In case the DeletedMessage found by the `where` argument doesn't exist, create a new DeletedMessage with this data.
     */
    create: XOR<DeletedMessageCreateInput, DeletedMessageUncheckedCreateInput>
    /**
     * In case the DeletedMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeletedMessageUpdateInput, DeletedMessageUncheckedUpdateInput>
  }

  /**
   * DeletedMessage delete
   */
  export type DeletedMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
    /**
     * Filter which DeletedMessage to delete.
     */
    where: DeletedMessageWhereUniqueInput
  }

  /**
   * DeletedMessage deleteMany
   */
  export type DeletedMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedMessages to delete
     */
    where?: DeletedMessageWhereInput
  }

  /**
   * DeletedMessage without action
   */
  export type DeletedMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedMessage
     */
    select?: DeletedMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedMessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    countryCode: 'countryCode',
    identityKey: 'identityKey',
    registrationId: 'registrationId',
    name: 'name',
    about: 'about',
    avatarUrl: 'avatarUrl',
    isOnline: 'isOnline',
    lastSeen: 'lastSeen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PrekeyBundleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    keyId: 'keyId',
    publicKey: 'publicKey',
    signature: 'signature',
    isUsed: 'isUsed',
    createdAt: 'createdAt'
  };

  export type PrekeyBundleScalarFieldEnum = (typeof PrekeyBundleScalarFieldEnum)[keyof typeof PrekeyBundleScalarFieldEnum]


  export const SignedPrekeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    keyId: 'keyId',
    publicKey: 'publicKey',
    signature: 'signature',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type SignedPrekeyScalarFieldEnum = (typeof SignedPrekeyScalarFieldEnum)[keyof typeof SignedPrekeyScalarFieldEnum]


  export const SessionStateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    remoteUserId: 'remoteUserId',
    sessionData: 'sessionData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionStateScalarFieldEnum = (typeof SessionStateScalarFieldEnum)[keyof typeof SessionStateScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recipientId: 'recipientId',
    groupId: 'groupId',
    encryptedContent: 'encryptedContent',
    messageType: 'messageType',
    timestamp: 'timestamp',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    status: 'status',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    replyToId: 'replyToId',
    isForwarded: 'isForwarded',
    mediaFileId: 'mediaFileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    avatarUrl: 'avatarUrl',
    creatorId: 'creatorId',
    senderKeyDistribution: 'senderKeyDistribution',
    isPublic: 'isPublic',
    maxMembers: 'maxMembers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const UserContactScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    contactId: 'contactId',
    name: 'name',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt'
  };

  export type UserContactScalarFieldEnum = (typeof UserContactScalarFieldEnum)[keyof typeof UserContactScalarFieldEnum]


  export const MediaFileScalarFieldEnum: {
    id: 'id',
    uploaderId: 'uploaderId',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    mediaType: 'mediaType',
    isUploaded: 'isUploaded',
    uploadedAt: 'uploadedAt',
    encryptionKey: 'encryptionKey',
    s3Key: 's3Key',
    s3Bucket: 's3Bucket',
    thumbnailUrl: 'thumbnailUrl',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type MediaFileScalarFieldEnum = (typeof MediaFileScalarFieldEnum)[keyof typeof MediaFileScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    isRevoked: 'isRevoked'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const OtpAttemptScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    otpCode: 'otpCode',
    attempts: 'attempts',
    isVerified: 'isVerified',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type OtpAttemptScalarFieldEnum = (typeof OtpAttemptScalarFieldEnum)[keyof typeof OtpAttemptScalarFieldEnum]


  export const SignalIdentityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    identityPublicKey: 'identityPublicKey',
    identityPrivateKey: 'identityPrivateKey',
    registrationId: 'registrationId',
    createdAt: 'createdAt'
  };

  export type SignalIdentityScalarFieldEnum = (typeof SignalIdentityScalarFieldEnum)[keyof typeof SignalIdentityScalarFieldEnum]


  export const SignalSessionScalarFieldEnum: {
    id: 'id',
    localUserId: 'localUserId',
    remoteUserId: 'remoteUserId',
    deviceId: 'deviceId',
    sessionData: 'sessionData',
    createdAt: 'createdAt',
    lastUsed: 'lastUsed'
  };

  export type SignalSessionScalarFieldEnum = (typeof SignalSessionScalarFieldEnum)[keyof typeof SignalSessionScalarFieldEnum]


  export const SenderKeyScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    senderId: 'senderId',
    deviceId: 'deviceId',
    keyData: 'keyData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SenderKeyScalarFieldEnum = (typeof SenderKeyScalarFieldEnum)[keyof typeof SenderKeyScalarFieldEnum]


  export const SignalMessageMetadataScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    cipherType: 'cipherType',
    deviceId: 'deviceId',
    senderKeyDistribution: 'senderKeyDistribution'
  };

  export type SignalMessageMetadataScalarFieldEnum = (typeof SignalMessageMetadataScalarFieldEnum)[keyof typeof SignalMessageMetadataScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactUserId: 'contactUserId',
    customName: 'customName',
    isBlocked: 'isBlocked',
    isMuted: 'isMuted',
    addedAt: 'addedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const DeletedMessageScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    deletedAt: 'deletedAt'
  };

  export type DeletedMessageScalarFieldEnum = (typeof DeletedMessageScalarFieldEnum)[keyof typeof DeletedMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'GroupMemberRole'
   */
  export type EnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole'>
    


  /**
   * Reference to a field of type 'GroupMemberRole[]'
   */
  export type ListEnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    countryCode?: StringFilter<"User"> | string
    identityKey?: StringFilter<"User"> | string
    registrationId?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    about?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isOnline?: BoolFilter<"User"> | boolean
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    prekeyBundles?: PrekeyBundleListRelationFilter
    signedPrekeys?: SignedPrekeyListRelationFilter
    signalIdentities?: SignalIdentityListRelationFilter
    groupMembers?: GroupMemberListRelationFilter
    createdGroups?: GroupListRelationFilter
    userContacts?: ContactListRelationFilter
    contacts?: ContactListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    otpAttempts?: OtpAttemptListRelationFilter
    deletedMessages?: DeletedMessageListRelationFilter
    sessionStates?: SessionStateListRelationFilter
    ownedContacts?: UserContactListRelationFilter
    contactedBy?: UserContactListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    identityKey?: SortOrder
    registrationId?: SortOrder
    name?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    prekeyBundles?: PrekeyBundleOrderByRelationAggregateInput
    signedPrekeys?: SignedPrekeyOrderByRelationAggregateInput
    signalIdentities?: SignalIdentityOrderByRelationAggregateInput
    groupMembers?: GroupMemberOrderByRelationAggregateInput
    createdGroups?: GroupOrderByRelationAggregateInput
    userContacts?: ContactOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    mediaFiles?: MediaFileOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    otpAttempts?: OtpAttemptOrderByRelationAggregateInput
    deletedMessages?: DeletedMessageOrderByRelationAggregateInput
    sessionStates?: SessionStateOrderByRelationAggregateInput
    ownedContacts?: UserContactOrderByRelationAggregateInput
    contactedBy?: UserContactOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    countryCode?: StringFilter<"User"> | string
    identityKey?: StringFilter<"User"> | string
    registrationId?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    about?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isOnline?: BoolFilter<"User"> | boolean
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    prekeyBundles?: PrekeyBundleListRelationFilter
    signedPrekeys?: SignedPrekeyListRelationFilter
    signalIdentities?: SignalIdentityListRelationFilter
    groupMembers?: GroupMemberListRelationFilter
    createdGroups?: GroupListRelationFilter
    userContacts?: ContactListRelationFilter
    contacts?: ContactListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    otpAttempts?: OtpAttemptListRelationFilter
    deletedMessages?: DeletedMessageListRelationFilter
    sessionStates?: SessionStateListRelationFilter
    ownedContacts?: UserContactListRelationFilter
    contactedBy?: UserContactListRelationFilter
  }, "id" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    identityKey?: SortOrder
    registrationId?: SortOrder
    name?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    countryCode?: StringWithAggregatesFilter<"User"> | string
    identityKey?: StringWithAggregatesFilter<"User"> | string
    registrationId?: IntWithAggregatesFilter<"User"> | number
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    about?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    lastSeen?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PrekeyBundleWhereInput = {
    AND?: PrekeyBundleWhereInput | PrekeyBundleWhereInput[]
    OR?: PrekeyBundleWhereInput[]
    NOT?: PrekeyBundleWhereInput | PrekeyBundleWhereInput[]
    id?: IntFilter<"PrekeyBundle"> | number
    userId?: StringFilter<"PrekeyBundle"> | string
    deviceId?: IntFilter<"PrekeyBundle"> | number
    keyId?: IntFilter<"PrekeyBundle"> | number
    publicKey?: StringFilter<"PrekeyBundle"> | string
    signature?: StringFilter<"PrekeyBundle"> | string
    isUsed?: BoolFilter<"PrekeyBundle"> | boolean
    createdAt?: DateTimeFilter<"PrekeyBundle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PrekeyBundleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PrekeyBundleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_deviceId_keyId?: PrekeyBundleUserIdDeviceIdKeyIdCompoundUniqueInput
    AND?: PrekeyBundleWhereInput | PrekeyBundleWhereInput[]
    OR?: PrekeyBundleWhereInput[]
    NOT?: PrekeyBundleWhereInput | PrekeyBundleWhereInput[]
    userId?: StringFilter<"PrekeyBundle"> | string
    deviceId?: IntFilter<"PrekeyBundle"> | number
    keyId?: IntFilter<"PrekeyBundle"> | number
    publicKey?: StringFilter<"PrekeyBundle"> | string
    signature?: StringFilter<"PrekeyBundle"> | string
    isUsed?: BoolFilter<"PrekeyBundle"> | boolean
    createdAt?: DateTimeFilter<"PrekeyBundle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceId_keyId">

  export type PrekeyBundleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    _count?: PrekeyBundleCountOrderByAggregateInput
    _avg?: PrekeyBundleAvgOrderByAggregateInput
    _max?: PrekeyBundleMaxOrderByAggregateInput
    _min?: PrekeyBundleMinOrderByAggregateInput
    _sum?: PrekeyBundleSumOrderByAggregateInput
  }

  export type PrekeyBundleScalarWhereWithAggregatesInput = {
    AND?: PrekeyBundleScalarWhereWithAggregatesInput | PrekeyBundleScalarWhereWithAggregatesInput[]
    OR?: PrekeyBundleScalarWhereWithAggregatesInput[]
    NOT?: PrekeyBundleScalarWhereWithAggregatesInput | PrekeyBundleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrekeyBundle"> | number
    userId?: StringWithAggregatesFilter<"PrekeyBundle"> | string
    deviceId?: IntWithAggregatesFilter<"PrekeyBundle"> | number
    keyId?: IntWithAggregatesFilter<"PrekeyBundle"> | number
    publicKey?: StringWithAggregatesFilter<"PrekeyBundle"> | string
    signature?: StringWithAggregatesFilter<"PrekeyBundle"> | string
    isUsed?: BoolWithAggregatesFilter<"PrekeyBundle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PrekeyBundle"> | Date | string
  }

  export type SignedPrekeyWhereInput = {
    AND?: SignedPrekeyWhereInput | SignedPrekeyWhereInput[]
    OR?: SignedPrekeyWhereInput[]
    NOT?: SignedPrekeyWhereInput | SignedPrekeyWhereInput[]
    id?: IntFilter<"SignedPrekey"> | number
    userId?: StringFilter<"SignedPrekey"> | string
    deviceId?: IntFilter<"SignedPrekey"> | number
    keyId?: IntFilter<"SignedPrekey"> | number
    publicKey?: StringFilter<"SignedPrekey"> | string
    signature?: StringFilter<"SignedPrekey"> | string
    timestamp?: DateTimeFilter<"SignedPrekey"> | Date | string
    createdAt?: DateTimeFilter<"SignedPrekey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SignedPrekeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SignedPrekeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_deviceId_keyId?: SignedPrekeyUserIdDeviceIdKeyIdCompoundUniqueInput
    AND?: SignedPrekeyWhereInput | SignedPrekeyWhereInput[]
    OR?: SignedPrekeyWhereInput[]
    NOT?: SignedPrekeyWhereInput | SignedPrekeyWhereInput[]
    userId?: StringFilter<"SignedPrekey"> | string
    deviceId?: IntFilter<"SignedPrekey"> | number
    keyId?: IntFilter<"SignedPrekey"> | number
    publicKey?: StringFilter<"SignedPrekey"> | string
    signature?: StringFilter<"SignedPrekey"> | string
    timestamp?: DateTimeFilter<"SignedPrekey"> | Date | string
    createdAt?: DateTimeFilter<"SignedPrekey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceId_keyId">

  export type SignedPrekeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: SignedPrekeyCountOrderByAggregateInput
    _avg?: SignedPrekeyAvgOrderByAggregateInput
    _max?: SignedPrekeyMaxOrderByAggregateInput
    _min?: SignedPrekeyMinOrderByAggregateInput
    _sum?: SignedPrekeySumOrderByAggregateInput
  }

  export type SignedPrekeyScalarWhereWithAggregatesInput = {
    AND?: SignedPrekeyScalarWhereWithAggregatesInput | SignedPrekeyScalarWhereWithAggregatesInput[]
    OR?: SignedPrekeyScalarWhereWithAggregatesInput[]
    NOT?: SignedPrekeyScalarWhereWithAggregatesInput | SignedPrekeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SignedPrekey"> | number
    userId?: StringWithAggregatesFilter<"SignedPrekey"> | string
    deviceId?: IntWithAggregatesFilter<"SignedPrekey"> | number
    keyId?: IntWithAggregatesFilter<"SignedPrekey"> | number
    publicKey?: StringWithAggregatesFilter<"SignedPrekey"> | string
    signature?: StringWithAggregatesFilter<"SignedPrekey"> | string
    timestamp?: DateTimeWithAggregatesFilter<"SignedPrekey"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SignedPrekey"> | Date | string
  }

  export type SessionStateWhereInput = {
    AND?: SessionStateWhereInput | SessionStateWhereInput[]
    OR?: SessionStateWhereInput[]
    NOT?: SessionStateWhereInput | SessionStateWhereInput[]
    id?: StringFilter<"SessionState"> | string
    userId?: StringFilter<"SessionState"> | string
    remoteUserId?: StringFilter<"SessionState"> | string
    sessionData?: BytesFilter<"SessionState"> | Buffer
    createdAt?: DateTimeFilter<"SessionState"> | Date | string
    updatedAt?: DateTimeFilter<"SessionState"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionStateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    remoteUserId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_remoteUserId?: SessionStateUserIdRemoteUserIdCompoundUniqueInput
    AND?: SessionStateWhereInput | SessionStateWhereInput[]
    OR?: SessionStateWhereInput[]
    NOT?: SessionStateWhereInput | SessionStateWhereInput[]
    userId?: StringFilter<"SessionState"> | string
    remoteUserId?: StringFilter<"SessionState"> | string
    sessionData?: BytesFilter<"SessionState"> | Buffer
    createdAt?: DateTimeFilter<"SessionState"> | Date | string
    updatedAt?: DateTimeFilter<"SessionState"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_remoteUserId">

  export type SessionStateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    remoteUserId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionStateCountOrderByAggregateInput
    _max?: SessionStateMaxOrderByAggregateInput
    _min?: SessionStateMinOrderByAggregateInput
  }

  export type SessionStateScalarWhereWithAggregatesInput = {
    AND?: SessionStateScalarWhereWithAggregatesInput | SessionStateScalarWhereWithAggregatesInput[]
    OR?: SessionStateScalarWhereWithAggregatesInput[]
    NOT?: SessionStateScalarWhereWithAggregatesInput | SessionStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionState"> | string
    userId?: StringWithAggregatesFilter<"SessionState"> | string
    remoteUserId?: StringWithAggregatesFilter<"SessionState"> | string
    sessionData?: BytesWithAggregatesFilter<"SessionState"> | Buffer
    createdAt?: DateTimeWithAggregatesFilter<"SessionState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionState"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    groupId?: StringNullableFilter<"Message"> | string | null
    encryptedContent?: BytesFilter<"Message"> | Buffer
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    timestamp?: BigIntFilter<"Message"> | bigint | number
    sentAt?: DateTimeFilter<"Message"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    replyToId?: StringNullableFilter<"Message"> | string | null
    isForwarded?: BoolFilter<"Message"> | boolean
    mediaFileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipient?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    replyTo?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    mediaFile?: XOR<MediaFileNullableRelationFilter, MediaFileWhereInput> | null
    signalMetadata?: XOR<SignalMessageMetadataNullableRelationFilter, SignalMessageMetadataWhereInput> | null
    deletedMessages?: DeletedMessageListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    encryptedContent?: SortOrder
    messageType?: SortOrder
    timestamp?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    replyToId?: SortOrderInput | SortOrder
    isForwarded?: SortOrder
    mediaFileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    replyTo?: MessageOrderByWithRelationInput
    replies?: MessageOrderByRelationAggregateInput
    mediaFile?: MediaFileOrderByWithRelationInput
    signalMetadata?: SignalMessageMetadataOrderByWithRelationInput
    deletedMessages?: DeletedMessageOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    groupId?: StringNullableFilter<"Message"> | string | null
    encryptedContent?: BytesFilter<"Message"> | Buffer
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    timestamp?: BigIntFilter<"Message"> | bigint | number
    sentAt?: DateTimeFilter<"Message"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    replyToId?: StringNullableFilter<"Message"> | string | null
    isForwarded?: BoolFilter<"Message"> | boolean
    mediaFileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipient?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    replyTo?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    mediaFile?: XOR<MediaFileNullableRelationFilter, MediaFileWhereInput> | null
    signalMetadata?: XOR<SignalMessageMetadataNullableRelationFilter, SignalMessageMetadataWhereInput> | null
    deletedMessages?: DeletedMessageListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    encryptedContent?: SortOrder
    messageType?: SortOrder
    timestamp?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    replyToId?: SortOrderInput | SortOrder
    isForwarded?: SortOrder
    mediaFileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    encryptedContent?: BytesWithAggregatesFilter<"Message"> | Buffer
    messageType?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    timestamp?: BigIntWithAggregatesFilter<"Message"> | bigint | number
    sentAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    isDeleted?: BoolWithAggregatesFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    replyToId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isForwarded?: BoolWithAggregatesFilter<"Message"> | boolean
    mediaFileId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    avatarUrl?: StringNullableFilter<"Group"> | string | null
    creatorId?: StringFilter<"Group"> | string
    senderKeyDistribution?: BytesNullableFilter<"Group"> | Buffer | null
    isPublic?: BoolFilter<"Group"> | boolean
    maxMembers?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    senderKeyDistribution?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: GroupMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    avatarUrl?: StringNullableFilter<"Group"> | string | null
    creatorId?: StringFilter<"Group"> | string
    senderKeyDistribution?: BytesNullableFilter<"Group"> | Buffer | null
    isPublic?: BoolFilter<"Group"> | boolean
    maxMembers?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    senderKeyDistribution?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Group"> | string | null
    creatorId?: StringWithAggregatesFilter<"Group"> | string
    senderKeyDistribution?: BytesNullableWithAggregatesFilter<"Group"> | Buffer | null
    isPublic?: BoolWithAggregatesFilter<"Group"> | boolean
    maxMembers?: IntWithAggregatesFilter<"Group"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleWithAggregatesFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type UserContactWhereInput = {
    AND?: UserContactWhereInput | UserContactWhereInput[]
    OR?: UserContactWhereInput[]
    NOT?: UserContactWhereInput | UserContactWhereInput[]
    id?: StringFilter<"UserContact"> | string
    ownerId?: StringFilter<"UserContact"> | string
    contactId?: StringFilter<"UserContact"> | string
    name?: StringNullableFilter<"UserContact"> | string | null
    isBlocked?: BoolFilter<"UserContact"> | boolean
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserContactOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    contactId?: SortOrder
    name?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    contact?: UserOrderByWithRelationInput
  }

  export type UserContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId_contactId?: UserContactOwnerIdContactIdCompoundUniqueInput
    AND?: UserContactWhereInput | UserContactWhereInput[]
    OR?: UserContactWhereInput[]
    NOT?: UserContactWhereInput | UserContactWhereInput[]
    ownerId?: StringFilter<"UserContact"> | string
    contactId?: StringFilter<"UserContact"> | string
    name?: StringNullableFilter<"UserContact"> | string | null
    isBlocked?: BoolFilter<"UserContact"> | boolean
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "ownerId_contactId">

  export type UserContactOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    contactId?: SortOrder
    name?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    _count?: UserContactCountOrderByAggregateInput
    _max?: UserContactMaxOrderByAggregateInput
    _min?: UserContactMinOrderByAggregateInput
  }

  export type UserContactScalarWhereWithAggregatesInput = {
    AND?: UserContactScalarWhereWithAggregatesInput | UserContactScalarWhereWithAggregatesInput[]
    OR?: UserContactScalarWhereWithAggregatesInput[]
    NOT?: UserContactScalarWhereWithAggregatesInput | UserContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserContact"> | string
    ownerId?: StringWithAggregatesFilter<"UserContact"> | string
    contactId?: StringWithAggregatesFilter<"UserContact"> | string
    name?: StringNullableWithAggregatesFilter<"UserContact"> | string | null
    isBlocked?: BoolWithAggregatesFilter<"UserContact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserContact"> | Date | string
  }

  export type MediaFileWhereInput = {
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    id?: StringFilter<"MediaFile"> | string
    uploaderId?: StringFilter<"MediaFile"> | string
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: BigIntFilter<"MediaFile"> | bigint | number
    mediaType?: EnumMediaTypeNullableFilter<"MediaFile"> | $Enums.MediaType | null
    isUploaded?: BoolFilter<"MediaFile"> | boolean
    uploadedAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
    encryptionKey?: StringNullableFilter<"MediaFile"> | string | null
    s3Key?: StringFilter<"MediaFile"> | string
    s3Bucket?: StringFilter<"MediaFile"> | string
    thumbnailUrl?: StringNullableFilter<"MediaFile"> | string | null
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type MediaFileOrderByWithRelationInput = {
    id?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    isUploaded?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    encryptionKey?: SortOrderInput | SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    uploader?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type MediaFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    uploaderId?: StringFilter<"MediaFile"> | string
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: BigIntFilter<"MediaFile"> | bigint | number
    mediaType?: EnumMediaTypeNullableFilter<"MediaFile"> | $Enums.MediaType | null
    isUploaded?: BoolFilter<"MediaFile"> | boolean
    uploadedAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
    encryptionKey?: StringNullableFilter<"MediaFile"> | string | null
    s3Key?: StringFilter<"MediaFile"> | string
    s3Bucket?: StringFilter<"MediaFile"> | string
    thumbnailUrl?: StringNullableFilter<"MediaFile"> | string | null
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id">

  export type MediaFileOrderByWithAggregationInput = {
    id?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    isUploaded?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    encryptionKey?: SortOrderInput | SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: MediaFileCountOrderByAggregateInput
    _avg?: MediaFileAvgOrderByAggregateInput
    _max?: MediaFileMaxOrderByAggregateInput
    _min?: MediaFileMinOrderByAggregateInput
    _sum?: MediaFileSumOrderByAggregateInput
  }

  export type MediaFileScalarWhereWithAggregatesInput = {
    AND?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    OR?: MediaFileScalarWhereWithAggregatesInput[]
    NOT?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaFile"> | string
    uploaderId?: StringWithAggregatesFilter<"MediaFile"> | string
    filename?: StringWithAggregatesFilter<"MediaFile"> | string
    originalName?: StringWithAggregatesFilter<"MediaFile"> | string
    mimeType?: StringWithAggregatesFilter<"MediaFile"> | string
    size?: BigIntWithAggregatesFilter<"MediaFile"> | bigint | number
    mediaType?: EnumMediaTypeNullableWithAggregatesFilter<"MediaFile"> | $Enums.MediaType | null
    isUploaded?: BoolWithAggregatesFilter<"MediaFile"> | boolean
    uploadedAt?: DateTimeNullableWithAggregatesFilter<"MediaFile"> | Date | string | null
    encryptionKey?: StringNullableWithAggregatesFilter<"MediaFile"> | string | null
    s3Key?: StringWithAggregatesFilter<"MediaFile"> | string
    s3Bucket?: StringWithAggregatesFilter<"MediaFile"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"MediaFile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"MediaFile"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRevoked?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRevoked?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
  }

  export type OtpAttemptWhereInput = {
    AND?: OtpAttemptWhereInput | OtpAttemptWhereInput[]
    OR?: OtpAttemptWhereInput[]
    NOT?: OtpAttemptWhereInput | OtpAttemptWhereInput[]
    id?: StringFilter<"OtpAttempt"> | string
    phoneNumber?: StringFilter<"OtpAttempt"> | string
    otpCode?: StringFilter<"OtpAttempt"> | string
    attempts?: IntFilter<"OtpAttempt"> | number
    isVerified?: BoolFilter<"OtpAttempt"> | boolean
    expiresAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    createdAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    userId?: StringNullableFilter<"OtpAttempt"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type OtpAttemptOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    otpCode?: SortOrder
    attempts?: SortOrder
    isVerified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpAttemptWhereInput | OtpAttemptWhereInput[]
    OR?: OtpAttemptWhereInput[]
    NOT?: OtpAttemptWhereInput | OtpAttemptWhereInput[]
    phoneNumber?: StringFilter<"OtpAttempt"> | string
    otpCode?: StringFilter<"OtpAttempt"> | string
    attempts?: IntFilter<"OtpAttempt"> | number
    isVerified?: BoolFilter<"OtpAttempt"> | boolean
    expiresAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    createdAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    userId?: StringNullableFilter<"OtpAttempt"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type OtpAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    otpCode?: SortOrder
    attempts?: SortOrder
    isVerified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: OtpAttemptCountOrderByAggregateInput
    _avg?: OtpAttemptAvgOrderByAggregateInput
    _max?: OtpAttemptMaxOrderByAggregateInput
    _min?: OtpAttemptMinOrderByAggregateInput
    _sum?: OtpAttemptSumOrderByAggregateInput
  }

  export type OtpAttemptScalarWhereWithAggregatesInput = {
    AND?: OtpAttemptScalarWhereWithAggregatesInput | OtpAttemptScalarWhereWithAggregatesInput[]
    OR?: OtpAttemptScalarWhereWithAggregatesInput[]
    NOT?: OtpAttemptScalarWhereWithAggregatesInput | OtpAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OtpAttempt"> | string
    phoneNumber?: StringWithAggregatesFilter<"OtpAttempt"> | string
    otpCode?: StringWithAggregatesFilter<"OtpAttempt"> | string
    attempts?: IntWithAggregatesFilter<"OtpAttempt"> | number
    isVerified?: BoolWithAggregatesFilter<"OtpAttempt"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"OtpAttempt"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OtpAttempt"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"OtpAttempt"> | string | null
  }

  export type SignalIdentityWhereInput = {
    AND?: SignalIdentityWhereInput | SignalIdentityWhereInput[]
    OR?: SignalIdentityWhereInput[]
    NOT?: SignalIdentityWhereInput | SignalIdentityWhereInput[]
    id?: StringFilter<"SignalIdentity"> | string
    userId?: StringFilter<"SignalIdentity"> | string
    deviceId?: IntFilter<"SignalIdentity"> | number
    identityPublicKey?: StringFilter<"SignalIdentity"> | string
    identityPrivateKey?: StringFilter<"SignalIdentity"> | string
    registrationId?: IntFilter<"SignalIdentity"> | number
    createdAt?: DateTimeFilter<"SignalIdentity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SignalIdentityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    identityPublicKey?: SortOrder
    identityPrivateKey?: SortOrder
    registrationId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SignalIdentityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_deviceId?: SignalIdentityUserIdDeviceIdCompoundUniqueInput
    AND?: SignalIdentityWhereInput | SignalIdentityWhereInput[]
    OR?: SignalIdentityWhereInput[]
    NOT?: SignalIdentityWhereInput | SignalIdentityWhereInput[]
    userId?: StringFilter<"SignalIdentity"> | string
    deviceId?: IntFilter<"SignalIdentity"> | number
    identityPublicKey?: StringFilter<"SignalIdentity"> | string
    identityPrivateKey?: StringFilter<"SignalIdentity"> | string
    registrationId?: IntFilter<"SignalIdentity"> | number
    createdAt?: DateTimeFilter<"SignalIdentity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceId">

  export type SignalIdentityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    identityPublicKey?: SortOrder
    identityPrivateKey?: SortOrder
    registrationId?: SortOrder
    createdAt?: SortOrder
    _count?: SignalIdentityCountOrderByAggregateInput
    _avg?: SignalIdentityAvgOrderByAggregateInput
    _max?: SignalIdentityMaxOrderByAggregateInput
    _min?: SignalIdentityMinOrderByAggregateInput
    _sum?: SignalIdentitySumOrderByAggregateInput
  }

  export type SignalIdentityScalarWhereWithAggregatesInput = {
    AND?: SignalIdentityScalarWhereWithAggregatesInput | SignalIdentityScalarWhereWithAggregatesInput[]
    OR?: SignalIdentityScalarWhereWithAggregatesInput[]
    NOT?: SignalIdentityScalarWhereWithAggregatesInput | SignalIdentityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SignalIdentity"> | string
    userId?: StringWithAggregatesFilter<"SignalIdentity"> | string
    deviceId?: IntWithAggregatesFilter<"SignalIdentity"> | number
    identityPublicKey?: StringWithAggregatesFilter<"SignalIdentity"> | string
    identityPrivateKey?: StringWithAggregatesFilter<"SignalIdentity"> | string
    registrationId?: IntWithAggregatesFilter<"SignalIdentity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SignalIdentity"> | Date | string
  }

  export type SignalSessionWhereInput = {
    AND?: SignalSessionWhereInput | SignalSessionWhereInput[]
    OR?: SignalSessionWhereInput[]
    NOT?: SignalSessionWhereInput | SignalSessionWhereInput[]
    id?: StringFilter<"SignalSession"> | string
    localUserId?: StringFilter<"SignalSession"> | string
    remoteUserId?: StringFilter<"SignalSession"> | string
    deviceId?: IntFilter<"SignalSession"> | number
    sessionData?: StringFilter<"SignalSession"> | string
    createdAt?: DateTimeFilter<"SignalSession"> | Date | string
    lastUsed?: DateTimeFilter<"SignalSession"> | Date | string
  }

  export type SignalSessionOrderByWithRelationInput = {
    id?: SortOrder
    localUserId?: SortOrder
    remoteUserId?: SortOrder
    deviceId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type SignalSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    localUserId_remoteUserId_deviceId?: SignalSessionLocalUserIdRemoteUserIdDeviceIdCompoundUniqueInput
    AND?: SignalSessionWhereInput | SignalSessionWhereInput[]
    OR?: SignalSessionWhereInput[]
    NOT?: SignalSessionWhereInput | SignalSessionWhereInput[]
    localUserId?: StringFilter<"SignalSession"> | string
    remoteUserId?: StringFilter<"SignalSession"> | string
    deviceId?: IntFilter<"SignalSession"> | number
    sessionData?: StringFilter<"SignalSession"> | string
    createdAt?: DateTimeFilter<"SignalSession"> | Date | string
    lastUsed?: DateTimeFilter<"SignalSession"> | Date | string
  }, "id" | "localUserId_remoteUserId_deviceId">

  export type SignalSessionOrderByWithAggregationInput = {
    id?: SortOrder
    localUserId?: SortOrder
    remoteUserId?: SortOrder
    deviceId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    _count?: SignalSessionCountOrderByAggregateInput
    _avg?: SignalSessionAvgOrderByAggregateInput
    _max?: SignalSessionMaxOrderByAggregateInput
    _min?: SignalSessionMinOrderByAggregateInput
    _sum?: SignalSessionSumOrderByAggregateInput
  }

  export type SignalSessionScalarWhereWithAggregatesInput = {
    AND?: SignalSessionScalarWhereWithAggregatesInput | SignalSessionScalarWhereWithAggregatesInput[]
    OR?: SignalSessionScalarWhereWithAggregatesInput[]
    NOT?: SignalSessionScalarWhereWithAggregatesInput | SignalSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SignalSession"> | string
    localUserId?: StringWithAggregatesFilter<"SignalSession"> | string
    remoteUserId?: StringWithAggregatesFilter<"SignalSession"> | string
    deviceId?: IntWithAggregatesFilter<"SignalSession"> | number
    sessionData?: StringWithAggregatesFilter<"SignalSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SignalSession"> | Date | string
    lastUsed?: DateTimeWithAggregatesFilter<"SignalSession"> | Date | string
  }

  export type SenderKeyWhereInput = {
    AND?: SenderKeyWhereInput | SenderKeyWhereInput[]
    OR?: SenderKeyWhereInput[]
    NOT?: SenderKeyWhereInput | SenderKeyWhereInput[]
    id?: StringFilter<"SenderKey"> | string
    groupId?: StringFilter<"SenderKey"> | string
    senderId?: StringFilter<"SenderKey"> | string
    deviceId?: IntFilter<"SenderKey"> | number
    keyData?: StringFilter<"SenderKey"> | string
    createdAt?: DateTimeFilter<"SenderKey"> | Date | string
    updatedAt?: DateTimeFilter<"SenderKey"> | Date | string
  }

  export type SenderKeyOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    deviceId?: SortOrder
    keyData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_senderId_deviceId?: SenderKeyGroupIdSenderIdDeviceIdCompoundUniqueInput
    AND?: SenderKeyWhereInput | SenderKeyWhereInput[]
    OR?: SenderKeyWhereInput[]
    NOT?: SenderKeyWhereInput | SenderKeyWhereInput[]
    groupId?: StringFilter<"SenderKey"> | string
    senderId?: StringFilter<"SenderKey"> | string
    deviceId?: IntFilter<"SenderKey"> | number
    keyData?: StringFilter<"SenderKey"> | string
    createdAt?: DateTimeFilter<"SenderKey"> | Date | string
    updatedAt?: DateTimeFilter<"SenderKey"> | Date | string
  }, "id" | "groupId_senderId_deviceId">

  export type SenderKeyOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    deviceId?: SortOrder
    keyData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SenderKeyCountOrderByAggregateInput
    _avg?: SenderKeyAvgOrderByAggregateInput
    _max?: SenderKeyMaxOrderByAggregateInput
    _min?: SenderKeyMinOrderByAggregateInput
    _sum?: SenderKeySumOrderByAggregateInput
  }

  export type SenderKeyScalarWhereWithAggregatesInput = {
    AND?: SenderKeyScalarWhereWithAggregatesInput | SenderKeyScalarWhereWithAggregatesInput[]
    OR?: SenderKeyScalarWhereWithAggregatesInput[]
    NOT?: SenderKeyScalarWhereWithAggregatesInput | SenderKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SenderKey"> | string
    groupId?: StringWithAggregatesFilter<"SenderKey"> | string
    senderId?: StringWithAggregatesFilter<"SenderKey"> | string
    deviceId?: IntWithAggregatesFilter<"SenderKey"> | number
    keyData?: StringWithAggregatesFilter<"SenderKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SenderKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SenderKey"> | Date | string
  }

  export type SignalMessageMetadataWhereInput = {
    AND?: SignalMessageMetadataWhereInput | SignalMessageMetadataWhereInput[]
    OR?: SignalMessageMetadataWhereInput[]
    NOT?: SignalMessageMetadataWhereInput | SignalMessageMetadataWhereInput[]
    id?: StringFilter<"SignalMessageMetadata"> | string
    messageId?: StringFilter<"SignalMessageMetadata"> | string
    cipherType?: IntFilter<"SignalMessageMetadata"> | number
    deviceId?: IntFilter<"SignalMessageMetadata"> | number
    senderKeyDistribution?: StringNullableFilter<"SignalMessageMetadata"> | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type SignalMessageMetadataOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    cipherType?: SortOrder
    deviceId?: SortOrder
    senderKeyDistribution?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type SignalMessageMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: SignalMessageMetadataWhereInput | SignalMessageMetadataWhereInput[]
    OR?: SignalMessageMetadataWhereInput[]
    NOT?: SignalMessageMetadataWhereInput | SignalMessageMetadataWhereInput[]
    cipherType?: IntFilter<"SignalMessageMetadata"> | number
    deviceId?: IntFilter<"SignalMessageMetadata"> | number
    senderKeyDistribution?: StringNullableFilter<"SignalMessageMetadata"> | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }, "id" | "messageId">

  export type SignalMessageMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    cipherType?: SortOrder
    deviceId?: SortOrder
    senderKeyDistribution?: SortOrderInput | SortOrder
    _count?: SignalMessageMetadataCountOrderByAggregateInput
    _avg?: SignalMessageMetadataAvgOrderByAggregateInput
    _max?: SignalMessageMetadataMaxOrderByAggregateInput
    _min?: SignalMessageMetadataMinOrderByAggregateInput
    _sum?: SignalMessageMetadataSumOrderByAggregateInput
  }

  export type SignalMessageMetadataScalarWhereWithAggregatesInput = {
    AND?: SignalMessageMetadataScalarWhereWithAggregatesInput | SignalMessageMetadataScalarWhereWithAggregatesInput[]
    OR?: SignalMessageMetadataScalarWhereWithAggregatesInput[]
    NOT?: SignalMessageMetadataScalarWhereWithAggregatesInput | SignalMessageMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SignalMessageMetadata"> | string
    messageId?: StringWithAggregatesFilter<"SignalMessageMetadata"> | string
    cipherType?: IntWithAggregatesFilter<"SignalMessageMetadata"> | number
    deviceId?: IntWithAggregatesFilter<"SignalMessageMetadata"> | number
    senderKeyDistribution?: StringNullableWithAggregatesFilter<"SignalMessageMetadata"> | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    contactUserId?: StringFilter<"Contact"> | string
    customName?: StringNullableFilter<"Contact"> | string | null
    isBlocked?: BoolFilter<"Contact"> | boolean
    isMuted?: BoolFilter<"Contact"> | boolean
    addedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contactUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactUserId?: SortOrder
    customName?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    isMuted?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contactUser?: UserOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_contactUserId?: ContactUserIdContactUserIdCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    userId?: StringFilter<"Contact"> | string
    contactUserId?: StringFilter<"Contact"> | string
    customName?: StringNullableFilter<"Contact"> | string | null
    isBlocked?: BoolFilter<"Contact"> | boolean
    isMuted?: BoolFilter<"Contact"> | boolean
    addedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contactUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_contactUserId">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactUserId?: SortOrder
    customName?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    isMuted?: SortOrder
    addedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    userId?: StringWithAggregatesFilter<"Contact"> | string
    contactUserId?: StringWithAggregatesFilter<"Contact"> | string
    customName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isBlocked?: BoolWithAggregatesFilter<"Contact"> | boolean
    isMuted?: BoolWithAggregatesFilter<"Contact"> | boolean
    addedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type DeletedMessageWhereInput = {
    AND?: DeletedMessageWhereInput | DeletedMessageWhereInput[]
    OR?: DeletedMessageWhereInput[]
    NOT?: DeletedMessageWhereInput | DeletedMessageWhereInput[]
    id?: StringFilter<"DeletedMessage"> | string
    messageId?: StringFilter<"DeletedMessage"> | string
    userId?: StringFilter<"DeletedMessage"> | string
    deletedAt?: DateTimeFilter<"DeletedMessage"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeletedMessageOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DeletedMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: DeletedMessageMessageIdUserIdCompoundUniqueInput
    AND?: DeletedMessageWhereInput | DeletedMessageWhereInput[]
    OR?: DeletedMessageWhereInput[]
    NOT?: DeletedMessageWhereInput | DeletedMessageWhereInput[]
    messageId?: StringFilter<"DeletedMessage"> | string
    userId?: StringFilter<"DeletedMessage"> | string
    deletedAt?: DateTimeFilter<"DeletedMessage"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type DeletedMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
    _count?: DeletedMessageCountOrderByAggregateInput
    _max?: DeletedMessageMaxOrderByAggregateInput
    _min?: DeletedMessageMinOrderByAggregateInput
  }

  export type DeletedMessageScalarWhereWithAggregatesInput = {
    AND?: DeletedMessageScalarWhereWithAggregatesInput | DeletedMessageScalarWhereWithAggregatesInput[]
    OR?: DeletedMessageScalarWhereWithAggregatesInput[]
    NOT?: DeletedMessageScalarWhereWithAggregatesInput | DeletedMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeletedMessage"> | string
    messageId?: StringWithAggregatesFilter<"DeletedMessage"> | string
    userId?: StringWithAggregatesFilter<"DeletedMessage"> | string
    deletedAt?: DateTimeWithAggregatesFilter<"DeletedMessage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleCreateInput = {
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPrekeyBundlesInput
  }

  export type PrekeyBundleUncheckedCreateInput = {
    id?: number
    userId: string
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PrekeyBundleUpdateInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrekeyBundlesNestedInput
  }

  export type PrekeyBundleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleCreateManyInput = {
    id?: number
    userId: string
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PrekeyBundleUpdateManyMutationInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyCreateInput = {
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSignedPrekeysInput
  }

  export type SignedPrekeyUncheckedCreateInput = {
    id?: number
    userId: string
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SignedPrekeyUpdateInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSignedPrekeysNestedInput
  }

  export type SignedPrekeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyCreateManyInput = {
    id?: number
    userId: string
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SignedPrekeyUpdateManyMutationInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateCreateInput = {
    id?: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionStatesInput
  }

  export type SessionStateUncheckedCreateInput = {
    id?: string
    userId: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionStatesNestedInput
  }

  export type SessionStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateCreateManyInput = {
    id?: string
    userId: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    creatorId: string
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    creatorId: string
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactCreateInput = {
    id?: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedContactsInput
    contact: UserCreateNestedOneWithoutContactedByInput
  }

  export type UserContactUncheckedCreateInput = {
    id?: string
    ownerId: string
    contactId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type UserContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    contact?: UserUpdateOneRequiredWithoutContactedByNestedInput
  }

  export type UserContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactCreateManyInput = {
    id?: string
    ownerId: string
    contactId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type UserContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutMediaFilesInput
    messages?: MessageCreateNestedManyWithoutMediaFileInput
  }

  export type MediaFileUncheckedCreateInput = {
    id?: string
    uploaderId: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutMediaFileInput
  }

  export type MediaFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutMediaFilesNestedInput
    messages?: MessageUpdateManyWithoutMediaFileNestedInput
  }

  export type MediaFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutMediaFileNestedInput
  }

  export type MediaFileCreateManyInput = {
    id?: string
    uploaderId: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type MediaFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpAttemptCreateInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutOtpAttemptsInput
  }

  export type OtpAttemptUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    userId?: string | null
  }

  export type OtpAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOtpAttemptsNestedInput
  }

  export type OtpAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtpAttemptCreateManyInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    userId?: string | null
  }

  export type OtpAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignalIdentityCreateInput = {
    id?: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSignalIdentitiesInput
  }

  export type SignalIdentityUncheckedCreateInput = {
    id?: string
    userId: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
  }

  export type SignalIdentityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSignalIdentitiesNestedInput
  }

  export type SignalIdentityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalIdentityCreateManyInput = {
    id?: string
    userId: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
  }

  export type SignalIdentityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalIdentityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalSessionCreateInput = {
    id?: string
    localUserId: string
    remoteUserId: string
    deviceId: number
    sessionData: string
    createdAt?: Date | string
    lastUsed?: Date | string
  }

  export type SignalSessionUncheckedCreateInput = {
    id?: string
    localUserId: string
    remoteUserId: string
    deviceId: number
    sessionData: string
    createdAt?: Date | string
    lastUsed?: Date | string
  }

  export type SignalSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localUserId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    sessionData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localUserId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    sessionData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalSessionCreateManyInput = {
    id?: string
    localUserId: string
    remoteUserId: string
    deviceId: number
    sessionData: string
    createdAt?: Date | string
    lastUsed?: Date | string
  }

  export type SignalSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    localUserId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    sessionData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    localUserId?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    sessionData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderKeyCreateInput = {
    id?: string
    groupId: string
    senderId: string
    deviceId: number
    keyData: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SenderKeyUncheckedCreateInput = {
    id?: string
    groupId: string
    senderId: string
    deviceId: number
    keyData: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SenderKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderKeyCreateManyInput = {
    id?: string
    groupId: string
    senderId: string
    deviceId: number
    keyData: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SenderKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    keyData?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalMessageMetadataCreateInput = {
    id?: string
    cipherType: number
    deviceId: number
    senderKeyDistribution?: string | null
    message: MessageCreateNestedOneWithoutSignalMetadataInput
  }

  export type SignalMessageMetadataUncheckedCreateInput = {
    id?: string
    messageId: string
    cipherType: number
    deviceId: number
    senderKeyDistribution?: string | null
  }

  export type SignalMessageMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
    message?: MessageUpdateOneRequiredWithoutSignalMetadataNestedInput
  }

  export type SignalMessageMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignalMessageMetadataCreateManyInput = {
    id?: string
    messageId: string
    cipherType: number
    deviceId: number
    senderKeyDistribution?: string | null
  }

  export type SignalMessageMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignalMessageMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateInput = {
    id?: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutUserContactsInput
    contactUser: UserCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    userId: string
    contactUserId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserContactsNestedInput
    contactUser?: UserUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactUserId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: string
    userId: string
    contactUserId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactUserId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageCreateInput = {
    id?: string
    deletedAt?: Date | string
    message: MessageCreateNestedOneWithoutDeletedMessagesInput
    user: UserCreateNestedOneWithoutDeletedMessagesInput
  }

  export type DeletedMessageUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    deletedAt?: Date | string
  }

  export type DeletedMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutDeletedMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutDeletedMessagesNestedInput
  }

  export type DeletedMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    deletedAt?: Date | string
  }

  export type DeletedMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type PrekeyBundleListRelationFilter = {
    every?: PrekeyBundleWhereInput
    some?: PrekeyBundleWhereInput
    none?: PrekeyBundleWhereInput
  }

  export type SignedPrekeyListRelationFilter = {
    every?: SignedPrekeyWhereInput
    some?: SignedPrekeyWhereInput
    none?: SignedPrekeyWhereInput
  }

  export type SignalIdentityListRelationFilter = {
    every?: SignalIdentityWhereInput
    some?: SignalIdentityWhereInput
    none?: SignalIdentityWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type MediaFileListRelationFilter = {
    every?: MediaFileWhereInput
    some?: MediaFileWhereInput
    none?: MediaFileWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type OtpAttemptListRelationFilter = {
    every?: OtpAttemptWhereInput
    some?: OtpAttemptWhereInput
    none?: OtpAttemptWhereInput
  }

  export type DeletedMessageListRelationFilter = {
    every?: DeletedMessageWhereInput
    some?: DeletedMessageWhereInput
    none?: DeletedMessageWhereInput
  }

  export type SessionStateListRelationFilter = {
    every?: SessionStateWhereInput
    some?: SessionStateWhereInput
    none?: SessionStateWhereInput
  }

  export type UserContactListRelationFilter = {
    every?: UserContactWhereInput
    some?: UserContactWhereInput
    none?: UserContactWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrekeyBundleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignedPrekeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignalIdentityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtpAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeletedMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    identityKey?: SortOrder
    registrationId?: SortOrder
    name?: SortOrder
    about?: SortOrder
    avatarUrl?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    registrationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    identityKey?: SortOrder
    registrationId?: SortOrder
    name?: SortOrder
    about?: SortOrder
    avatarUrl?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    identityKey?: SortOrder
    registrationId?: SortOrder
    name?: SortOrder
    about?: SortOrder
    avatarUrl?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    registrationId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PrekeyBundleUserIdDeviceIdKeyIdCompoundUniqueInput = {
    userId: string
    deviceId: number
    keyId: number
  }

  export type PrekeyBundleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PrekeyBundleAvgOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
  }

  export type PrekeyBundleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PrekeyBundleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PrekeyBundleSumOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
  }

  export type SignedPrekeyUserIdDeviceIdKeyIdCompoundUniqueInput = {
    userId: string
    deviceId: number
    keyId: number
  }

  export type SignedPrekeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type SignedPrekeyAvgOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
  }

  export type SignedPrekeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type SignedPrekeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
    publicKey?: SortOrder
    signature?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type SignedPrekeySumOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    keyId?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type SessionStateUserIdRemoteUserIdCompoundUniqueInput = {
    userId: string
    remoteUserId: string
  }

  export type SessionStateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    remoteUserId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionStateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    remoteUserId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionStateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    remoteUserId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GroupNullableRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type MessageNullableRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MediaFileNullableRelationFilter = {
    is?: MediaFileWhereInput | null
    isNot?: MediaFileWhereInput | null
  }

  export type SignalMessageMetadataNullableRelationFilter = {
    is?: SignalMessageMetadataWhereInput | null
    isNot?: SignalMessageMetadataWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    groupId?: SortOrder
    encryptedContent?: SortOrder
    messageType?: SortOrder
    timestamp?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    replyToId?: SortOrder
    isForwarded?: SortOrder
    mediaFileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    groupId?: SortOrder
    encryptedContent?: SortOrder
    messageType?: SortOrder
    timestamp?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    replyToId?: SortOrder
    isForwarded?: SortOrder
    mediaFileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    groupId?: SortOrder
    encryptedContent?: SortOrder
    messageType?: SortOrder
    timestamp?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    replyToId?: SortOrder
    isForwarded?: SortOrder
    mediaFileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    creatorId?: SortOrder
    senderKeyDistribution?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    creatorId?: SortOrder
    senderKeyDistribution?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    creatorId?: SortOrder
    senderKeyDistribution?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type EnumGroupMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleFilter<$PrismaModel> | $Enums.GroupMemberRole
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumGroupMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
  }

  export type UserContactOwnerIdContactIdCompoundUniqueInput = {
    ownerId: string
    contactId: string
  }

  export type UserContactCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    contactId?: SortOrder
    name?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserContactMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    contactId?: SortOrder
    name?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserContactMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    contactId?: SortOrder
    name?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableFilter<$PrismaModel> | $Enums.MediaType | null
  }

  export type MediaFileCountOrderByAggregateInput = {
    id?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    isUploaded?: SortOrder
    uploadedAt?: SortOrder
    encryptionKey?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaFileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MediaFileMaxOrderByAggregateInput = {
    id?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    isUploaded?: SortOrder
    uploadedAt?: SortOrder
    encryptionKey?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaFileMinOrderByAggregateInput = {
    id?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    isUploaded?: SortOrder
    uploadedAt?: SortOrder
    encryptionKey?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaFileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type OtpAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    otpCode?: SortOrder
    attempts?: SortOrder
    isVerified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type OtpAttemptAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OtpAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    otpCode?: SortOrder
    attempts?: SortOrder
    isVerified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type OtpAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    otpCode?: SortOrder
    attempts?: SortOrder
    isVerified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type OtpAttemptSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type SignalIdentityUserIdDeviceIdCompoundUniqueInput = {
    userId: string
    deviceId: number
  }

  export type SignalIdentityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    identityPublicKey?: SortOrder
    identityPrivateKey?: SortOrder
    registrationId?: SortOrder
    createdAt?: SortOrder
  }

  export type SignalIdentityAvgOrderByAggregateInput = {
    deviceId?: SortOrder
    registrationId?: SortOrder
  }

  export type SignalIdentityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    identityPublicKey?: SortOrder
    identityPrivateKey?: SortOrder
    registrationId?: SortOrder
    createdAt?: SortOrder
  }

  export type SignalIdentityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    identityPublicKey?: SortOrder
    identityPrivateKey?: SortOrder
    registrationId?: SortOrder
    createdAt?: SortOrder
  }

  export type SignalIdentitySumOrderByAggregateInput = {
    deviceId?: SortOrder
    registrationId?: SortOrder
  }

  export type SignalSessionLocalUserIdRemoteUserIdDeviceIdCompoundUniqueInput = {
    localUserId: string
    remoteUserId: string
    deviceId: number
  }

  export type SignalSessionCountOrderByAggregateInput = {
    id?: SortOrder
    localUserId?: SortOrder
    remoteUserId?: SortOrder
    deviceId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type SignalSessionAvgOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type SignalSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    localUserId?: SortOrder
    remoteUserId?: SortOrder
    deviceId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type SignalSessionMinOrderByAggregateInput = {
    id?: SortOrder
    localUserId?: SortOrder
    remoteUserId?: SortOrder
    deviceId?: SortOrder
    sessionData?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type SignalSessionSumOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type SenderKeyGroupIdSenderIdDeviceIdCompoundUniqueInput = {
    groupId: string
    senderId: string
    deviceId: number
  }

  export type SenderKeyCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    deviceId?: SortOrder
    keyData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderKeyAvgOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type SenderKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    deviceId?: SortOrder
    keyData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderKeyMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    deviceId?: SortOrder
    keyData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderKeySumOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type SignalMessageMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    cipherType?: SortOrder
    deviceId?: SortOrder
    senderKeyDistribution?: SortOrder
  }

  export type SignalMessageMetadataAvgOrderByAggregateInput = {
    cipherType?: SortOrder
    deviceId?: SortOrder
  }

  export type SignalMessageMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    cipherType?: SortOrder
    deviceId?: SortOrder
    senderKeyDistribution?: SortOrder
  }

  export type SignalMessageMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    cipherType?: SortOrder
    deviceId?: SortOrder
    senderKeyDistribution?: SortOrder
  }

  export type SignalMessageMetadataSumOrderByAggregateInput = {
    cipherType?: SortOrder
    deviceId?: SortOrder
  }

  export type ContactUserIdContactUserIdCompoundUniqueInput = {
    userId: string
    contactUserId: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactUserId?: SortOrder
    customName?: SortOrder
    isBlocked?: SortOrder
    isMuted?: SortOrder
    addedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactUserId?: SortOrder
    customName?: SortOrder
    isBlocked?: SortOrder
    isMuted?: SortOrder
    addedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactUserId?: SortOrder
    customName?: SortOrder
    isBlocked?: SortOrder
    isMuted?: SortOrder
    addedAt?: SortOrder
  }

  export type DeletedMessageMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type DeletedMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeletedMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeletedMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PrekeyBundleCreateNestedManyWithoutUserInput = {
    create?: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput> | PrekeyBundleCreateWithoutUserInput[] | PrekeyBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrekeyBundleCreateOrConnectWithoutUserInput | PrekeyBundleCreateOrConnectWithoutUserInput[]
    createMany?: PrekeyBundleCreateManyUserInputEnvelope
    connect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
  }

  export type SignedPrekeyCreateNestedManyWithoutUserInput = {
    create?: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput> | SignedPrekeyCreateWithoutUserInput[] | SignedPrekeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignedPrekeyCreateOrConnectWithoutUserInput | SignedPrekeyCreateOrConnectWithoutUserInput[]
    createMany?: SignedPrekeyCreateManyUserInputEnvelope
    connect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
  }

  export type SignalIdentityCreateNestedManyWithoutUserInput = {
    create?: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput> | SignalIdentityCreateWithoutUserInput[] | SignalIdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignalIdentityCreateOrConnectWithoutUserInput | SignalIdentityCreateOrConnectWithoutUserInput[]
    createMany?: SignalIdentityCreateManyUserInputEnvelope
    connect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutContactUserInput = {
    create?: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput> | ContactCreateWithoutContactUserInput[] | ContactUncheckedCreateWithoutContactUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactUserInput | ContactCreateOrConnectWithoutContactUserInput[]
    createMany?: ContactCreateManyContactUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MediaFileCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput> | MediaFileCreateWithoutUploaderInput[] | MediaFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUploaderInput | MediaFileCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaFileCreateManyUploaderInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type OtpAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput> | OtpAttemptCreateWithoutUserInput[] | OtpAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpAttemptCreateOrConnectWithoutUserInput | OtpAttemptCreateOrConnectWithoutUserInput[]
    createMany?: OtpAttemptCreateManyUserInputEnvelope
    connect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
  }

  export type DeletedMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput> | DeletedMessageCreateWithoutUserInput[] | DeletedMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutUserInput | DeletedMessageCreateOrConnectWithoutUserInput[]
    createMany?: DeletedMessageCreateManyUserInputEnvelope
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
  }

  export type SessionStateCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput> | SessionStateCreateWithoutUserInput[] | SessionStateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionStateCreateOrConnectWithoutUserInput | SessionStateCreateOrConnectWithoutUserInput[]
    createMany?: SessionStateCreateManyUserInputEnvelope
    connect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
  }

  export type UserContactCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput> | UserContactCreateWithoutOwnerInput[] | UserContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutOwnerInput | UserContactCreateOrConnectWithoutOwnerInput[]
    createMany?: UserContactCreateManyOwnerInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type UserContactCreateNestedManyWithoutContactInput = {
    create?: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput> | UserContactCreateWithoutContactInput[] | UserContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutContactInput | UserContactCreateOrConnectWithoutContactInput[]
    createMany?: UserContactCreateManyContactInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PrekeyBundleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput> | PrekeyBundleCreateWithoutUserInput[] | PrekeyBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrekeyBundleCreateOrConnectWithoutUserInput | PrekeyBundleCreateOrConnectWithoutUserInput[]
    createMany?: PrekeyBundleCreateManyUserInputEnvelope
    connect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
  }

  export type SignedPrekeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput> | SignedPrekeyCreateWithoutUserInput[] | SignedPrekeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignedPrekeyCreateOrConnectWithoutUserInput | SignedPrekeyCreateOrConnectWithoutUserInput[]
    createMany?: SignedPrekeyCreateManyUserInputEnvelope
    connect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
  }

  export type SignalIdentityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput> | SignalIdentityCreateWithoutUserInput[] | SignalIdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignalIdentityCreateOrConnectWithoutUserInput | SignalIdentityCreateOrConnectWithoutUserInput[]
    createMany?: SignalIdentityCreateManyUserInputEnvelope
    connect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutContactUserInput = {
    create?: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput> | ContactCreateWithoutContactUserInput[] | ContactUncheckedCreateWithoutContactUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactUserInput | ContactCreateOrConnectWithoutContactUserInput[]
    createMany?: ContactCreateManyContactUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MediaFileUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput> | MediaFileCreateWithoutUploaderInput[] | MediaFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUploaderInput | MediaFileCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaFileCreateManyUploaderInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type OtpAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput> | OtpAttemptCreateWithoutUserInput[] | OtpAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpAttemptCreateOrConnectWithoutUserInput | OtpAttemptCreateOrConnectWithoutUserInput[]
    createMany?: OtpAttemptCreateManyUserInputEnvelope
    connect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
  }

  export type DeletedMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput> | DeletedMessageCreateWithoutUserInput[] | DeletedMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutUserInput | DeletedMessageCreateOrConnectWithoutUserInput[]
    createMany?: DeletedMessageCreateManyUserInputEnvelope
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
  }

  export type SessionStateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput> | SessionStateCreateWithoutUserInput[] | SessionStateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionStateCreateOrConnectWithoutUserInput | SessionStateCreateOrConnectWithoutUserInput[]
    createMany?: SessionStateCreateManyUserInputEnvelope
    connect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
  }

  export type UserContactUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput> | UserContactCreateWithoutOwnerInput[] | UserContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutOwnerInput | UserContactCreateOrConnectWithoutOwnerInput[]
    createMany?: UserContactCreateManyOwnerInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type UserContactUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput> | UserContactCreateWithoutContactInput[] | UserContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutContactInput | UserContactCreateOrConnectWithoutContactInput[]
    createMany?: UserContactCreateManyContactInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PrekeyBundleUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput> | PrekeyBundleCreateWithoutUserInput[] | PrekeyBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrekeyBundleCreateOrConnectWithoutUserInput | PrekeyBundleCreateOrConnectWithoutUserInput[]
    upsert?: PrekeyBundleUpsertWithWhereUniqueWithoutUserInput | PrekeyBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrekeyBundleCreateManyUserInputEnvelope
    set?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    disconnect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    delete?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    connect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    update?: PrekeyBundleUpdateWithWhereUniqueWithoutUserInput | PrekeyBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrekeyBundleUpdateManyWithWhereWithoutUserInput | PrekeyBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrekeyBundleScalarWhereInput | PrekeyBundleScalarWhereInput[]
  }

  export type SignedPrekeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput> | SignedPrekeyCreateWithoutUserInput[] | SignedPrekeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignedPrekeyCreateOrConnectWithoutUserInput | SignedPrekeyCreateOrConnectWithoutUserInput[]
    upsert?: SignedPrekeyUpsertWithWhereUniqueWithoutUserInput | SignedPrekeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignedPrekeyCreateManyUserInputEnvelope
    set?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    disconnect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    delete?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    connect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    update?: SignedPrekeyUpdateWithWhereUniqueWithoutUserInput | SignedPrekeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignedPrekeyUpdateManyWithWhereWithoutUserInput | SignedPrekeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignedPrekeyScalarWhereInput | SignedPrekeyScalarWhereInput[]
  }

  export type SignalIdentityUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput> | SignalIdentityCreateWithoutUserInput[] | SignalIdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignalIdentityCreateOrConnectWithoutUserInput | SignalIdentityCreateOrConnectWithoutUserInput[]
    upsert?: SignalIdentityUpsertWithWhereUniqueWithoutUserInput | SignalIdentityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignalIdentityCreateManyUserInputEnvelope
    set?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    disconnect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    delete?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    connect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    update?: SignalIdentityUpdateWithWhereUniqueWithoutUserInput | SignalIdentityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignalIdentityUpdateManyWithWhereWithoutUserInput | SignalIdentityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignalIdentityScalarWhereInput | SignalIdentityScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatorInput | GroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatorInput | GroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatorInput | GroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutContactUserNestedInput = {
    create?: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput> | ContactCreateWithoutContactUserInput[] | ContactUncheckedCreateWithoutContactUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactUserInput | ContactCreateOrConnectWithoutContactUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutContactUserInput | ContactUpsertWithWhereUniqueWithoutContactUserInput[]
    createMany?: ContactCreateManyContactUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutContactUserInput | ContactUpdateWithWhereUniqueWithoutContactUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutContactUserInput | ContactUpdateManyWithWhereWithoutContactUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type MediaFileUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput> | MediaFileCreateWithoutUploaderInput[] | MediaFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUploaderInput | MediaFileCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutUploaderInput | MediaFileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaFileCreateManyUploaderInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutUploaderInput | MediaFileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutUploaderInput | MediaFileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type OtpAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput> | OtpAttemptCreateWithoutUserInput[] | OtpAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpAttemptCreateOrConnectWithoutUserInput | OtpAttemptCreateOrConnectWithoutUserInput[]
    upsert?: OtpAttemptUpsertWithWhereUniqueWithoutUserInput | OtpAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpAttemptCreateManyUserInputEnvelope
    set?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    disconnect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    delete?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    connect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    update?: OtpAttemptUpdateWithWhereUniqueWithoutUserInput | OtpAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpAttemptUpdateManyWithWhereWithoutUserInput | OtpAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpAttemptScalarWhereInput | OtpAttemptScalarWhereInput[]
  }

  export type DeletedMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput> | DeletedMessageCreateWithoutUserInput[] | DeletedMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutUserInput | DeletedMessageCreateOrConnectWithoutUserInput[]
    upsert?: DeletedMessageUpsertWithWhereUniqueWithoutUserInput | DeletedMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletedMessageCreateManyUserInputEnvelope
    set?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    disconnect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    delete?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    update?: DeletedMessageUpdateWithWhereUniqueWithoutUserInput | DeletedMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletedMessageUpdateManyWithWhereWithoutUserInput | DeletedMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
  }

  export type SessionStateUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput> | SessionStateCreateWithoutUserInput[] | SessionStateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionStateCreateOrConnectWithoutUserInput | SessionStateCreateOrConnectWithoutUserInput[]
    upsert?: SessionStateUpsertWithWhereUniqueWithoutUserInput | SessionStateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionStateCreateManyUserInputEnvelope
    set?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    disconnect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    delete?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    connect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    update?: SessionStateUpdateWithWhereUniqueWithoutUserInput | SessionStateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionStateUpdateManyWithWhereWithoutUserInput | SessionStateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionStateScalarWhereInput | SessionStateScalarWhereInput[]
  }

  export type UserContactUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput> | UserContactCreateWithoutOwnerInput[] | UserContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutOwnerInput | UserContactCreateOrConnectWithoutOwnerInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutOwnerInput | UserContactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UserContactCreateManyOwnerInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutOwnerInput | UserContactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutOwnerInput | UserContactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type UserContactUpdateManyWithoutContactNestedInput = {
    create?: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput> | UserContactCreateWithoutContactInput[] | UserContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutContactInput | UserContactCreateOrConnectWithoutContactInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutContactInput | UserContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: UserContactCreateManyContactInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutContactInput | UserContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutContactInput | UserContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput> | PrekeyBundleCreateWithoutUserInput[] | PrekeyBundleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrekeyBundleCreateOrConnectWithoutUserInput | PrekeyBundleCreateOrConnectWithoutUserInput[]
    upsert?: PrekeyBundleUpsertWithWhereUniqueWithoutUserInput | PrekeyBundleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrekeyBundleCreateManyUserInputEnvelope
    set?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    disconnect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    delete?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    connect?: PrekeyBundleWhereUniqueInput | PrekeyBundleWhereUniqueInput[]
    update?: PrekeyBundleUpdateWithWhereUniqueWithoutUserInput | PrekeyBundleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrekeyBundleUpdateManyWithWhereWithoutUserInput | PrekeyBundleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrekeyBundleScalarWhereInput | PrekeyBundleScalarWhereInput[]
  }

  export type SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput> | SignedPrekeyCreateWithoutUserInput[] | SignedPrekeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignedPrekeyCreateOrConnectWithoutUserInput | SignedPrekeyCreateOrConnectWithoutUserInput[]
    upsert?: SignedPrekeyUpsertWithWhereUniqueWithoutUserInput | SignedPrekeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignedPrekeyCreateManyUserInputEnvelope
    set?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    disconnect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    delete?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    connect?: SignedPrekeyWhereUniqueInput | SignedPrekeyWhereUniqueInput[]
    update?: SignedPrekeyUpdateWithWhereUniqueWithoutUserInput | SignedPrekeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignedPrekeyUpdateManyWithWhereWithoutUserInput | SignedPrekeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignedPrekeyScalarWhereInput | SignedPrekeyScalarWhereInput[]
  }

  export type SignalIdentityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput> | SignalIdentityCreateWithoutUserInput[] | SignalIdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignalIdentityCreateOrConnectWithoutUserInput | SignalIdentityCreateOrConnectWithoutUserInput[]
    upsert?: SignalIdentityUpsertWithWhereUniqueWithoutUserInput | SignalIdentityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignalIdentityCreateManyUserInputEnvelope
    set?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    disconnect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    delete?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    connect?: SignalIdentityWhereUniqueInput | SignalIdentityWhereUniqueInput[]
    update?: SignalIdentityUpdateWithWhereUniqueWithoutUserInput | SignalIdentityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignalIdentityUpdateManyWithWhereWithoutUserInput | SignalIdentityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignalIdentityScalarWhereInput | SignalIdentityScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatorInput | GroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatorInput | GroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatorInput | GroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutContactUserNestedInput = {
    create?: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput> | ContactCreateWithoutContactUserInput[] | ContactUncheckedCreateWithoutContactUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactUserInput | ContactCreateOrConnectWithoutContactUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutContactUserInput | ContactUpsertWithWhereUniqueWithoutContactUserInput[]
    createMany?: ContactCreateManyContactUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutContactUserInput | ContactUpdateWithWhereUniqueWithoutContactUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutContactUserInput | ContactUpdateManyWithWhereWithoutContactUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type MediaFileUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput> | MediaFileCreateWithoutUploaderInput[] | MediaFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUploaderInput | MediaFileCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutUploaderInput | MediaFileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaFileCreateManyUploaderInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutUploaderInput | MediaFileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutUploaderInput | MediaFileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type OtpAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput> | OtpAttemptCreateWithoutUserInput[] | OtpAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpAttemptCreateOrConnectWithoutUserInput | OtpAttemptCreateOrConnectWithoutUserInput[]
    upsert?: OtpAttemptUpsertWithWhereUniqueWithoutUserInput | OtpAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpAttemptCreateManyUserInputEnvelope
    set?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    disconnect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    delete?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    connect?: OtpAttemptWhereUniqueInput | OtpAttemptWhereUniqueInput[]
    update?: OtpAttemptUpdateWithWhereUniqueWithoutUserInput | OtpAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpAttemptUpdateManyWithWhereWithoutUserInput | OtpAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpAttemptScalarWhereInput | OtpAttemptScalarWhereInput[]
  }

  export type DeletedMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput> | DeletedMessageCreateWithoutUserInput[] | DeletedMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutUserInput | DeletedMessageCreateOrConnectWithoutUserInput[]
    upsert?: DeletedMessageUpsertWithWhereUniqueWithoutUserInput | DeletedMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletedMessageCreateManyUserInputEnvelope
    set?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    disconnect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    delete?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    update?: DeletedMessageUpdateWithWhereUniqueWithoutUserInput | DeletedMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletedMessageUpdateManyWithWhereWithoutUserInput | DeletedMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
  }

  export type SessionStateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput> | SessionStateCreateWithoutUserInput[] | SessionStateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionStateCreateOrConnectWithoutUserInput | SessionStateCreateOrConnectWithoutUserInput[]
    upsert?: SessionStateUpsertWithWhereUniqueWithoutUserInput | SessionStateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionStateCreateManyUserInputEnvelope
    set?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    disconnect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    delete?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    connect?: SessionStateWhereUniqueInput | SessionStateWhereUniqueInput[]
    update?: SessionStateUpdateWithWhereUniqueWithoutUserInput | SessionStateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionStateUpdateManyWithWhereWithoutUserInput | SessionStateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionStateScalarWhereInput | SessionStateScalarWhereInput[]
  }

  export type UserContactUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput> | UserContactCreateWithoutOwnerInput[] | UserContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutOwnerInput | UserContactCreateOrConnectWithoutOwnerInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutOwnerInput | UserContactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UserContactCreateManyOwnerInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutOwnerInput | UserContactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutOwnerInput | UserContactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type UserContactUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput> | UserContactCreateWithoutContactInput[] | UserContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutContactInput | UserContactCreateOrConnectWithoutContactInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutContactInput | UserContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: UserContactCreateManyContactInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutContactInput | UserContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutContactInput | UserContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPrekeyBundlesInput = {
    create?: XOR<UserCreateWithoutPrekeyBundlesInput, UserUncheckedCreateWithoutPrekeyBundlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrekeyBundlesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPrekeyBundlesNestedInput = {
    create?: XOR<UserCreateWithoutPrekeyBundlesInput, UserUncheckedCreateWithoutPrekeyBundlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrekeyBundlesInput
    upsert?: UserUpsertWithoutPrekeyBundlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrekeyBundlesInput, UserUpdateWithoutPrekeyBundlesInput>, UserUncheckedUpdateWithoutPrekeyBundlesInput>
  }

  export type UserCreateNestedOneWithoutSignedPrekeysInput = {
    create?: XOR<UserCreateWithoutSignedPrekeysInput, UserUncheckedCreateWithoutSignedPrekeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignedPrekeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSignedPrekeysNestedInput = {
    create?: XOR<UserCreateWithoutSignedPrekeysInput, UserUncheckedCreateWithoutSignedPrekeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignedPrekeysInput
    upsert?: UserUpsertWithoutSignedPrekeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSignedPrekeysInput, UserUpdateWithoutSignedPrekeysInput>, UserUncheckedUpdateWithoutSignedPrekeysInput>
  }

  export type UserCreateNestedOneWithoutSessionStatesInput = {
    create?: XOR<UserCreateWithoutSessionStatesInput, UserUncheckedCreateWithoutSessionStatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionStatesInput
    connect?: UserWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type UserUpdateOneRequiredWithoutSessionStatesNestedInput = {
    create?: XOR<UserCreateWithoutSessionStatesInput, UserUncheckedCreateWithoutSessionStatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionStatesInput
    upsert?: UserUpsertWithoutSessionStatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionStatesInput, UserUpdateWithoutSessionStatesInput>, UserUncheckedUpdateWithoutSessionStatesInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    connect?: GroupWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutReplyToInput = {
    create?: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput> | MessageCreateWithoutReplyToInput[] | MessageUncheckedCreateWithoutReplyToInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplyToInput | MessageCreateOrConnectWithoutReplyToInput[]
    createMany?: MessageCreateManyReplyToInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MediaFileCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MediaFileCreateWithoutMessagesInput, MediaFileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MediaFileCreateOrConnectWithoutMessagesInput
    connect?: MediaFileWhereUniqueInput
  }

  export type SignalMessageMetadataCreateNestedOneWithoutMessageInput = {
    create?: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
    connectOrCreate?: SignalMessageMetadataCreateOrConnectWithoutMessageInput
    connect?: SignalMessageMetadataWhereUniqueInput
  }

  export type DeletedMessageCreateNestedManyWithoutMessageInput = {
    create?: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput> | DeletedMessageCreateWithoutMessageInput[] | DeletedMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutMessageInput | DeletedMessageCreateOrConnectWithoutMessageInput[]
    createMany?: DeletedMessageCreateManyMessageInputEnvelope
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReplyToInput = {
    create?: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput> | MessageCreateWithoutReplyToInput[] | MessageUncheckedCreateWithoutReplyToInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplyToInput | MessageCreateOrConnectWithoutReplyToInput[]
    createMany?: MessageCreateManyReplyToInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
    connectOrCreate?: SignalMessageMetadataCreateOrConnectWithoutMessageInput
    connect?: SignalMessageMetadataWhereUniqueInput
  }

  export type DeletedMessageUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput> | DeletedMessageCreateWithoutMessageInput[] | DeletedMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutMessageInput | DeletedMessageCreateOrConnectWithoutMessageInput[]
    createMany?: DeletedMessageCreateManyMessageInputEnvelope
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type GroupUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    upsert?: GroupUpsertWithoutMessagesInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMessagesInput, GroupUpdateWithoutMessagesInput>, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    upsert?: MessageUpsertWithoutRepliesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRepliesInput, MessageUpdateWithoutRepliesInput>, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateManyWithoutReplyToNestedInput = {
    create?: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput> | MessageCreateWithoutReplyToInput[] | MessageUncheckedCreateWithoutReplyToInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplyToInput | MessageCreateOrConnectWithoutReplyToInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReplyToInput | MessageUpsertWithWhereUniqueWithoutReplyToInput[]
    createMany?: MessageCreateManyReplyToInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReplyToInput | MessageUpdateWithWhereUniqueWithoutReplyToInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReplyToInput | MessageUpdateManyWithWhereWithoutReplyToInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MediaFileUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<MediaFileCreateWithoutMessagesInput, MediaFileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MediaFileCreateOrConnectWithoutMessagesInput
    upsert?: MediaFileUpsertWithoutMessagesInput
    disconnect?: MediaFileWhereInput | boolean
    delete?: MediaFileWhereInput | boolean
    connect?: MediaFileWhereUniqueInput
    update?: XOR<XOR<MediaFileUpdateToOneWithWhereWithoutMessagesInput, MediaFileUpdateWithoutMessagesInput>, MediaFileUncheckedUpdateWithoutMessagesInput>
  }

  export type SignalMessageMetadataUpdateOneWithoutMessageNestedInput = {
    create?: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
    connectOrCreate?: SignalMessageMetadataCreateOrConnectWithoutMessageInput
    upsert?: SignalMessageMetadataUpsertWithoutMessageInput
    disconnect?: SignalMessageMetadataWhereInput | boolean
    delete?: SignalMessageMetadataWhereInput | boolean
    connect?: SignalMessageMetadataWhereUniqueInput
    update?: XOR<XOR<SignalMessageMetadataUpdateToOneWithWhereWithoutMessageInput, SignalMessageMetadataUpdateWithoutMessageInput>, SignalMessageMetadataUncheckedUpdateWithoutMessageInput>
  }

  export type DeletedMessageUpdateManyWithoutMessageNestedInput = {
    create?: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput> | DeletedMessageCreateWithoutMessageInput[] | DeletedMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutMessageInput | DeletedMessageCreateOrConnectWithoutMessageInput[]
    upsert?: DeletedMessageUpsertWithWhereUniqueWithoutMessageInput | DeletedMessageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: DeletedMessageCreateManyMessageInputEnvelope
    set?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    disconnect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    delete?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    update?: DeletedMessageUpdateWithWhereUniqueWithoutMessageInput | DeletedMessageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: DeletedMessageUpdateManyWithWhereWithoutMessageInput | DeletedMessageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReplyToNestedInput = {
    create?: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput> | MessageCreateWithoutReplyToInput[] | MessageUncheckedCreateWithoutReplyToInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplyToInput | MessageCreateOrConnectWithoutReplyToInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReplyToInput | MessageUpsertWithWhereUniqueWithoutReplyToInput[]
    createMany?: MessageCreateManyReplyToInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReplyToInput | MessageUpdateWithWhereUniqueWithoutReplyToInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReplyToInput | MessageUpdateManyWithWhereWithoutReplyToInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
    connectOrCreate?: SignalMessageMetadataCreateOrConnectWithoutMessageInput
    upsert?: SignalMessageMetadataUpsertWithoutMessageInput
    disconnect?: SignalMessageMetadataWhereInput | boolean
    delete?: SignalMessageMetadataWhereInput | boolean
    connect?: SignalMessageMetadataWhereUniqueInput
    update?: XOR<XOR<SignalMessageMetadataUpdateToOneWithWhereWithoutMessageInput, SignalMessageMetadataUpdateWithoutMessageInput>, SignalMessageMetadataUncheckedUpdateWithoutMessageInput>
  }

  export type DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput> | DeletedMessageCreateWithoutMessageInput[] | DeletedMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: DeletedMessageCreateOrConnectWithoutMessageInput | DeletedMessageCreateOrConnectWithoutMessageInput[]
    upsert?: DeletedMessageUpsertWithWhereUniqueWithoutMessageInput | DeletedMessageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: DeletedMessageCreateManyMessageInputEnvelope
    set?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    disconnect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    delete?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    connect?: DeletedMessageWhereUniqueInput | DeletedMessageWhereUniqueInput[]
    update?: DeletedMessageUpdateWithWhereUniqueWithoutMessageInput | DeletedMessageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: DeletedMessageUpdateManyWithWhereWithoutMessageInput | DeletedMessageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    upsert?: UserUpsertWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGroupsInput, UserUpdateWithoutCreatedGroupsInput>, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembersInput = {
    create?: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGroupMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.GroupMemberRole
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembersNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersInput
    upsert?: UserUpsertWithoutGroupMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembersInput, UserUpdateWithoutGroupMembersInput>, UserUncheckedUpdateWithoutGroupMembersInput>
  }

  export type UserCreateNestedOneWithoutOwnedContactsInput = {
    create?: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContactedByInput = {
    create?: XOR<UserCreateWithoutContactedByInput, UserUncheckedCreateWithoutContactedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOwnedContactsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedContactsInput
    upsert?: UserUpsertWithoutOwnedContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedContactsInput, UserUpdateWithoutOwnedContactsInput>, UserUncheckedUpdateWithoutOwnedContactsInput>
  }

  export type UserUpdateOneRequiredWithoutContactedByNestedInput = {
    create?: XOR<UserCreateWithoutContactedByInput, UserUncheckedCreateWithoutContactedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactedByInput
    upsert?: UserUpsertWithoutContactedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactedByInput, UserUpdateWithoutContactedByInput>, UserUncheckedUpdateWithoutContactedByInput>
  }

  export type UserCreateNestedOneWithoutMediaFilesInput = {
    create?: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaFilesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutMediaFileInput = {
    create?: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput> | MessageCreateWithoutMediaFileInput[] | MessageUncheckedCreateWithoutMediaFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMediaFileInput | MessageCreateOrConnectWithoutMediaFileInput[]
    createMany?: MessageCreateManyMediaFileInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutMediaFileInput = {
    create?: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput> | MessageCreateWithoutMediaFileInput[] | MessageUncheckedCreateWithoutMediaFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMediaFileInput | MessageCreateOrConnectWithoutMediaFileInput[]
    createMany?: MessageCreateManyMediaFileInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NullableEnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType | null
  }

  export type UserUpdateOneRequiredWithoutMediaFilesNestedInput = {
    create?: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaFilesInput
    upsert?: UserUpsertWithoutMediaFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaFilesInput, UserUpdateWithoutMediaFilesInput>, UserUncheckedUpdateWithoutMediaFilesInput>
  }

  export type MessageUpdateManyWithoutMediaFileNestedInput = {
    create?: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput> | MessageCreateWithoutMediaFileInput[] | MessageUncheckedCreateWithoutMediaFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMediaFileInput | MessageCreateOrConnectWithoutMediaFileInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMediaFileInput | MessageUpsertWithWhereUniqueWithoutMediaFileInput[]
    createMany?: MessageCreateManyMediaFileInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMediaFileInput | MessageUpdateWithWhereUniqueWithoutMediaFileInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMediaFileInput | MessageUpdateManyWithWhereWithoutMediaFileInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutMediaFileNestedInput = {
    create?: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput> | MessageCreateWithoutMediaFileInput[] | MessageUncheckedCreateWithoutMediaFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMediaFileInput | MessageCreateOrConnectWithoutMediaFileInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMediaFileInput | MessageUpsertWithWhereUniqueWithoutMediaFileInput[]
    createMany?: MessageCreateManyMediaFileInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMediaFileInput | MessageUpdateWithWhereUniqueWithoutMediaFileInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMediaFileInput | MessageUpdateManyWithWhereWithoutMediaFileInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutOtpAttemptsInput = {
    create?: XOR<UserCreateWithoutOtpAttemptsInput, UserUncheckedCreateWithoutOtpAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutOtpAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutOtpAttemptsInput, UserUncheckedCreateWithoutOtpAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpAttemptsInput
    upsert?: UserUpsertWithoutOtpAttemptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpAttemptsInput, UserUpdateWithoutOtpAttemptsInput>, UserUncheckedUpdateWithoutOtpAttemptsInput>
  }

  export type UserCreateNestedOneWithoutSignalIdentitiesInput = {
    create?: XOR<UserCreateWithoutSignalIdentitiesInput, UserUncheckedCreateWithoutSignalIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalIdentitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSignalIdentitiesNestedInput = {
    create?: XOR<UserCreateWithoutSignalIdentitiesInput, UserUncheckedCreateWithoutSignalIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalIdentitiesInput
    upsert?: UserUpsertWithoutSignalIdentitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSignalIdentitiesInput, UserUpdateWithoutSignalIdentitiesInput>, UserUncheckedUpdateWithoutSignalIdentitiesInput>
  }

  export type MessageCreateNestedOneWithoutSignalMetadataInput = {
    create?: XOR<MessageCreateWithoutSignalMetadataInput, MessageUncheckedCreateWithoutSignalMetadataInput>
    connectOrCreate?: MessageCreateOrConnectWithoutSignalMetadataInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutSignalMetadataNestedInput = {
    create?: XOR<MessageCreateWithoutSignalMetadataInput, MessageUncheckedCreateWithoutSignalMetadataInput>
    connectOrCreate?: MessageCreateOrConnectWithoutSignalMetadataInput
    upsert?: MessageUpsertWithoutSignalMetadataInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutSignalMetadataInput, MessageUpdateWithoutSignalMetadataInput>, MessageUncheckedUpdateWithoutSignalMetadataInput>
  }

  export type UserCreateNestedOneWithoutUserContactsInput = {
    create?: XOR<UserCreateWithoutUserContactsInput, UserUncheckedCreateWithoutUserContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserContactsNestedInput = {
    create?: XOR<UserCreateWithoutUserContactsInput, UserUncheckedCreateWithoutUserContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactsInput
    upsert?: UserUpsertWithoutUserContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserContactsInput, UserUpdateWithoutUserContactsInput>, UserUncheckedUpdateWithoutUserContactsInput>
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type MessageCreateNestedOneWithoutDeletedMessagesInput = {
    create?: XOR<MessageCreateWithoutDeletedMessagesInput, MessageUncheckedCreateWithoutDeletedMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutDeletedMessagesInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeletedMessagesInput = {
    create?: XOR<UserCreateWithoutDeletedMessagesInput, UserUncheckedCreateWithoutDeletedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutDeletedMessagesNestedInput = {
    create?: XOR<MessageCreateWithoutDeletedMessagesInput, MessageUncheckedCreateWithoutDeletedMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutDeletedMessagesInput
    upsert?: MessageUpsertWithoutDeletedMessagesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutDeletedMessagesInput, MessageUpdateWithoutDeletedMessagesInput>, MessageUncheckedUpdateWithoutDeletedMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutDeletedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutDeletedMessagesInput, UserUncheckedCreateWithoutDeletedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedMessagesInput
    upsert?: UserUpsertWithoutDeletedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletedMessagesInput, UserUpdateWithoutDeletedMessagesInput>, UserUncheckedUpdateWithoutDeletedMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumGroupMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleFilter<$PrismaModel> | $Enums.GroupMemberRole
  }

  export type NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableFilter<$PrismaModel> | $Enums.MediaType | null
  }

  export type NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId: string
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type PrekeyBundleCreateWithoutUserInput = {
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PrekeyBundleUncheckedCreateWithoutUserInput = {
    id?: number
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PrekeyBundleCreateOrConnectWithoutUserInput = {
    where: PrekeyBundleWhereUniqueInput
    create: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput>
  }

  export type PrekeyBundleCreateManyUserInputEnvelope = {
    data: PrekeyBundleCreateManyUserInput | PrekeyBundleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SignedPrekeyCreateWithoutUserInput = {
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SignedPrekeyUncheckedCreateWithoutUserInput = {
    id?: number
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SignedPrekeyCreateOrConnectWithoutUserInput = {
    where: SignedPrekeyWhereUniqueInput
    create: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput>
  }

  export type SignedPrekeyCreateManyUserInputEnvelope = {
    data: SignedPrekeyCreateManyUserInput | SignedPrekeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SignalIdentityCreateWithoutUserInput = {
    id?: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
  }

  export type SignalIdentityUncheckedCreateWithoutUserInput = {
    id?: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
  }

  export type SignalIdentityCreateOrConnectWithoutUserInput = {
    where: SignalIdentityWhereUniqueInput
    create: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput>
  }

  export type SignalIdentityCreateManyUserInputEnvelope = {
    data: SignalIdentityCreateManyUserInput | SignalIdentityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupCreateManyCreatorInputEnvelope = {
    data: GroupCreateManyCreatorInput | GroupCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    id?: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
    contactUser: UserCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: string
    contactUserId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutContactUserInput = {
    id?: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutUserContactsInput
  }

  export type ContactUncheckedCreateWithoutContactUserInput = {
    id?: string
    userId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutContactUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput>
  }

  export type ContactCreateManyContactUserInputEnvelope = {
    data: ContactCreateManyContactUserInput | ContactCreateManyContactUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaFileCreateWithoutUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    messages?: MessageCreateNestedManyWithoutMediaFileInput
  }

  export type MediaFileUncheckedCreateWithoutUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutMediaFileInput
  }

  export type MediaFileCreateOrConnectWithoutUploaderInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput>
  }

  export type MediaFileCreateManyUploaderInputEnvelope = {
    data: MediaFileCreateManyUploaderInput | MediaFileCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OtpAttemptCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpAttemptCreateOrConnectWithoutUserInput = {
    where: OtpAttemptWhereUniqueInput
    create: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput>
  }

  export type OtpAttemptCreateManyUserInputEnvelope = {
    data: OtpAttemptCreateManyUserInput | OtpAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeletedMessageCreateWithoutUserInput = {
    id?: string
    deletedAt?: Date | string
    message: MessageCreateNestedOneWithoutDeletedMessagesInput
  }

  export type DeletedMessageUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    deletedAt?: Date | string
  }

  export type DeletedMessageCreateOrConnectWithoutUserInput = {
    where: DeletedMessageWhereUniqueInput
    create: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput>
  }

  export type DeletedMessageCreateManyUserInputEnvelope = {
    data: DeletedMessageCreateManyUserInput | DeletedMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionStateCreateWithoutUserInput = {
    id?: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionStateUncheckedCreateWithoutUserInput = {
    id?: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionStateCreateOrConnectWithoutUserInput = {
    where: SessionStateWhereUniqueInput
    create: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput>
  }

  export type SessionStateCreateManyUserInputEnvelope = {
    data: SessionStateCreateManyUserInput | SessionStateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserContactCreateWithoutOwnerInput = {
    id?: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
    contact: UserCreateNestedOneWithoutContactedByInput
  }

  export type UserContactUncheckedCreateWithoutOwnerInput = {
    id?: string
    contactId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type UserContactCreateOrConnectWithoutOwnerInput = {
    where: UserContactWhereUniqueInput
    create: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput>
  }

  export type UserContactCreateManyOwnerInputEnvelope = {
    data: UserContactCreateManyOwnerInput | UserContactCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserContactCreateWithoutContactInput = {
    id?: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedContactsInput
  }

  export type UserContactUncheckedCreateWithoutContactInput = {
    id?: string
    ownerId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type UserContactCreateOrConnectWithoutContactInput = {
    where: UserContactWhereUniqueInput
    create: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput>
  }

  export type UserContactCreateManyContactInputEnvelope = {
    data: UserContactCreateManyContactInput | UserContactCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    groupId?: StringNullableFilter<"Message"> | string | null
    encryptedContent?: BytesFilter<"Message"> | Buffer
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    timestamp?: BigIntFilter<"Message"> | bigint | number
    sentAt?: DateTimeFilter<"Message"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    replyToId?: StringNullableFilter<"Message"> | string | null
    isForwarded?: BoolFilter<"Message"> | boolean
    mediaFileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type PrekeyBundleUpsertWithWhereUniqueWithoutUserInput = {
    where: PrekeyBundleWhereUniqueInput
    update: XOR<PrekeyBundleUpdateWithoutUserInput, PrekeyBundleUncheckedUpdateWithoutUserInput>
    create: XOR<PrekeyBundleCreateWithoutUserInput, PrekeyBundleUncheckedCreateWithoutUserInput>
  }

  export type PrekeyBundleUpdateWithWhereUniqueWithoutUserInput = {
    where: PrekeyBundleWhereUniqueInput
    data: XOR<PrekeyBundleUpdateWithoutUserInput, PrekeyBundleUncheckedUpdateWithoutUserInput>
  }

  export type PrekeyBundleUpdateManyWithWhereWithoutUserInput = {
    where: PrekeyBundleScalarWhereInput
    data: XOR<PrekeyBundleUpdateManyMutationInput, PrekeyBundleUncheckedUpdateManyWithoutUserInput>
  }

  export type PrekeyBundleScalarWhereInput = {
    AND?: PrekeyBundleScalarWhereInput | PrekeyBundleScalarWhereInput[]
    OR?: PrekeyBundleScalarWhereInput[]
    NOT?: PrekeyBundleScalarWhereInput | PrekeyBundleScalarWhereInput[]
    id?: IntFilter<"PrekeyBundle"> | number
    userId?: StringFilter<"PrekeyBundle"> | string
    deviceId?: IntFilter<"PrekeyBundle"> | number
    keyId?: IntFilter<"PrekeyBundle"> | number
    publicKey?: StringFilter<"PrekeyBundle"> | string
    signature?: StringFilter<"PrekeyBundle"> | string
    isUsed?: BoolFilter<"PrekeyBundle"> | boolean
    createdAt?: DateTimeFilter<"PrekeyBundle"> | Date | string
  }

  export type SignedPrekeyUpsertWithWhereUniqueWithoutUserInput = {
    where: SignedPrekeyWhereUniqueInput
    update: XOR<SignedPrekeyUpdateWithoutUserInput, SignedPrekeyUncheckedUpdateWithoutUserInput>
    create: XOR<SignedPrekeyCreateWithoutUserInput, SignedPrekeyUncheckedCreateWithoutUserInput>
  }

  export type SignedPrekeyUpdateWithWhereUniqueWithoutUserInput = {
    where: SignedPrekeyWhereUniqueInput
    data: XOR<SignedPrekeyUpdateWithoutUserInput, SignedPrekeyUncheckedUpdateWithoutUserInput>
  }

  export type SignedPrekeyUpdateManyWithWhereWithoutUserInput = {
    where: SignedPrekeyScalarWhereInput
    data: XOR<SignedPrekeyUpdateManyMutationInput, SignedPrekeyUncheckedUpdateManyWithoutUserInput>
  }

  export type SignedPrekeyScalarWhereInput = {
    AND?: SignedPrekeyScalarWhereInput | SignedPrekeyScalarWhereInput[]
    OR?: SignedPrekeyScalarWhereInput[]
    NOT?: SignedPrekeyScalarWhereInput | SignedPrekeyScalarWhereInput[]
    id?: IntFilter<"SignedPrekey"> | number
    userId?: StringFilter<"SignedPrekey"> | string
    deviceId?: IntFilter<"SignedPrekey"> | number
    keyId?: IntFilter<"SignedPrekey"> | number
    publicKey?: StringFilter<"SignedPrekey"> | string
    signature?: StringFilter<"SignedPrekey"> | string
    timestamp?: DateTimeFilter<"SignedPrekey"> | Date | string
    createdAt?: DateTimeFilter<"SignedPrekey"> | Date | string
  }

  export type SignalIdentityUpsertWithWhereUniqueWithoutUserInput = {
    where: SignalIdentityWhereUniqueInput
    update: XOR<SignalIdentityUpdateWithoutUserInput, SignalIdentityUncheckedUpdateWithoutUserInput>
    create: XOR<SignalIdentityCreateWithoutUserInput, SignalIdentityUncheckedCreateWithoutUserInput>
  }

  export type SignalIdentityUpdateWithWhereUniqueWithoutUserInput = {
    where: SignalIdentityWhereUniqueInput
    data: XOR<SignalIdentityUpdateWithoutUserInput, SignalIdentityUncheckedUpdateWithoutUserInput>
  }

  export type SignalIdentityUpdateManyWithWhereWithoutUserInput = {
    where: SignalIdentityScalarWhereInput
    data: XOR<SignalIdentityUpdateManyMutationInput, SignalIdentityUncheckedUpdateManyWithoutUserInput>
  }

  export type SignalIdentityScalarWhereInput = {
    AND?: SignalIdentityScalarWhereInput | SignalIdentityScalarWhereInput[]
    OR?: SignalIdentityScalarWhereInput[]
    NOT?: SignalIdentityScalarWhereInput | SignalIdentityScalarWhereInput[]
    id?: StringFilter<"SignalIdentity"> | string
    userId?: StringFilter<"SignalIdentity"> | string
    deviceId?: IntFilter<"SignalIdentity"> | number
    identityPublicKey?: StringFilter<"SignalIdentity"> | string
    identityPrivateKey?: StringFilter<"SignalIdentity"> | string
    registrationId?: IntFilter<"SignalIdentity"> | number
    createdAt?: DateTimeFilter<"SignalIdentity"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
  }

  export type GroupUpdateManyWithWhereWithoutCreatorInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    avatarUrl?: StringNullableFilter<"Group"> | string | null
    creatorId?: StringFilter<"Group"> | string
    senderKeyDistribution?: BytesNullableFilter<"Group"> | Buffer | null
    isPublic?: BoolFilter<"Group"> | boolean
    maxMembers?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    contactUserId?: StringFilter<"Contact"> | string
    customName?: StringNullableFilter<"Contact"> | string | null
    isBlocked?: BoolFilter<"Contact"> | boolean
    isMuted?: BoolFilter<"Contact"> | boolean
    addedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutContactUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutContactUserInput, ContactUncheckedUpdateWithoutContactUserInput>
    create: XOR<ContactCreateWithoutContactUserInput, ContactUncheckedCreateWithoutContactUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutContactUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutContactUserInput, ContactUncheckedUpdateWithoutContactUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutContactUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutContactUserInput>
  }

  export type MediaFileUpsertWithWhereUniqueWithoutUploaderInput = {
    where: MediaFileWhereUniqueInput
    update: XOR<MediaFileUpdateWithoutUploaderInput, MediaFileUncheckedUpdateWithoutUploaderInput>
    create: XOR<MediaFileCreateWithoutUploaderInput, MediaFileUncheckedCreateWithoutUploaderInput>
  }

  export type MediaFileUpdateWithWhereUniqueWithoutUploaderInput = {
    where: MediaFileWhereUniqueInput
    data: XOR<MediaFileUpdateWithoutUploaderInput, MediaFileUncheckedUpdateWithoutUploaderInput>
  }

  export type MediaFileUpdateManyWithWhereWithoutUploaderInput = {
    where: MediaFileScalarWhereInput
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyWithoutUploaderInput>
  }

  export type MediaFileScalarWhereInput = {
    AND?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    OR?: MediaFileScalarWhereInput[]
    NOT?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    id?: StringFilter<"MediaFile"> | string
    uploaderId?: StringFilter<"MediaFile"> | string
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: BigIntFilter<"MediaFile"> | bigint | number
    mediaType?: EnumMediaTypeNullableFilter<"MediaFile"> | $Enums.MediaType | null
    isUploaded?: BoolFilter<"MediaFile"> | boolean
    uploadedAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
    encryptionKey?: StringNullableFilter<"MediaFile"> | string | null
    s3Key?: StringFilter<"MediaFile"> | string
    s3Bucket?: StringFilter<"MediaFile"> | string
    thumbnailUrl?: StringNullableFilter<"MediaFile"> | string | null
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaFile"> | Date | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
  }

  export type OtpAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpAttemptWhereUniqueInput
    update: XOR<OtpAttemptUpdateWithoutUserInput, OtpAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<OtpAttemptCreateWithoutUserInput, OtpAttemptUncheckedCreateWithoutUserInput>
  }

  export type OtpAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpAttemptWhereUniqueInput
    data: XOR<OtpAttemptUpdateWithoutUserInput, OtpAttemptUncheckedUpdateWithoutUserInput>
  }

  export type OtpAttemptUpdateManyWithWhereWithoutUserInput = {
    where: OtpAttemptScalarWhereInput
    data: XOR<OtpAttemptUpdateManyMutationInput, OtpAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpAttemptScalarWhereInput = {
    AND?: OtpAttemptScalarWhereInput | OtpAttemptScalarWhereInput[]
    OR?: OtpAttemptScalarWhereInput[]
    NOT?: OtpAttemptScalarWhereInput | OtpAttemptScalarWhereInput[]
    id?: StringFilter<"OtpAttempt"> | string
    phoneNumber?: StringFilter<"OtpAttempt"> | string
    otpCode?: StringFilter<"OtpAttempt"> | string
    attempts?: IntFilter<"OtpAttempt"> | number
    isVerified?: BoolFilter<"OtpAttempt"> | boolean
    expiresAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    createdAt?: DateTimeFilter<"OtpAttempt"> | Date | string
    userId?: StringNullableFilter<"OtpAttempt"> | string | null
  }

  export type DeletedMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: DeletedMessageWhereUniqueInput
    update: XOR<DeletedMessageUpdateWithoutUserInput, DeletedMessageUncheckedUpdateWithoutUserInput>
    create: XOR<DeletedMessageCreateWithoutUserInput, DeletedMessageUncheckedCreateWithoutUserInput>
  }

  export type DeletedMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: DeletedMessageWhereUniqueInput
    data: XOR<DeletedMessageUpdateWithoutUserInput, DeletedMessageUncheckedUpdateWithoutUserInput>
  }

  export type DeletedMessageUpdateManyWithWhereWithoutUserInput = {
    where: DeletedMessageScalarWhereInput
    data: XOR<DeletedMessageUpdateManyMutationInput, DeletedMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type DeletedMessageScalarWhereInput = {
    AND?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
    OR?: DeletedMessageScalarWhereInput[]
    NOT?: DeletedMessageScalarWhereInput | DeletedMessageScalarWhereInput[]
    id?: StringFilter<"DeletedMessage"> | string
    messageId?: StringFilter<"DeletedMessage"> | string
    userId?: StringFilter<"DeletedMessage"> | string
    deletedAt?: DateTimeFilter<"DeletedMessage"> | Date | string
  }

  export type SessionStateUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionStateWhereUniqueInput
    update: XOR<SessionStateUpdateWithoutUserInput, SessionStateUncheckedUpdateWithoutUserInput>
    create: XOR<SessionStateCreateWithoutUserInput, SessionStateUncheckedCreateWithoutUserInput>
  }

  export type SessionStateUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionStateWhereUniqueInput
    data: XOR<SessionStateUpdateWithoutUserInput, SessionStateUncheckedUpdateWithoutUserInput>
  }

  export type SessionStateUpdateManyWithWhereWithoutUserInput = {
    where: SessionStateScalarWhereInput
    data: XOR<SessionStateUpdateManyMutationInput, SessionStateUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionStateScalarWhereInput = {
    AND?: SessionStateScalarWhereInput | SessionStateScalarWhereInput[]
    OR?: SessionStateScalarWhereInput[]
    NOT?: SessionStateScalarWhereInput | SessionStateScalarWhereInput[]
    id?: StringFilter<"SessionState"> | string
    userId?: StringFilter<"SessionState"> | string
    remoteUserId?: StringFilter<"SessionState"> | string
    sessionData?: BytesFilter<"SessionState"> | Buffer
    createdAt?: DateTimeFilter<"SessionState"> | Date | string
    updatedAt?: DateTimeFilter<"SessionState"> | Date | string
  }

  export type UserContactUpsertWithWhereUniqueWithoutOwnerInput = {
    where: UserContactWhereUniqueInput
    update: XOR<UserContactUpdateWithoutOwnerInput, UserContactUncheckedUpdateWithoutOwnerInput>
    create: XOR<UserContactCreateWithoutOwnerInput, UserContactUncheckedCreateWithoutOwnerInput>
  }

  export type UserContactUpdateWithWhereUniqueWithoutOwnerInput = {
    where: UserContactWhereUniqueInput
    data: XOR<UserContactUpdateWithoutOwnerInput, UserContactUncheckedUpdateWithoutOwnerInput>
  }

  export type UserContactUpdateManyWithWhereWithoutOwnerInput = {
    where: UserContactScalarWhereInput
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UserContactScalarWhereInput = {
    AND?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
    OR?: UserContactScalarWhereInput[]
    NOT?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
    id?: StringFilter<"UserContact"> | string
    ownerId?: StringFilter<"UserContact"> | string
    contactId?: StringFilter<"UserContact"> | string
    name?: StringNullableFilter<"UserContact"> | string | null
    isBlocked?: BoolFilter<"UserContact"> | boolean
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
  }

  export type UserContactUpsertWithWhereUniqueWithoutContactInput = {
    where: UserContactWhereUniqueInput
    update: XOR<UserContactUpdateWithoutContactInput, UserContactUncheckedUpdateWithoutContactInput>
    create: XOR<UserContactCreateWithoutContactInput, UserContactUncheckedCreateWithoutContactInput>
  }

  export type UserContactUpdateWithWhereUniqueWithoutContactInput = {
    where: UserContactWhereUniqueInput
    data: XOR<UserContactUpdateWithoutContactInput, UserContactUncheckedUpdateWithoutContactInput>
  }

  export type UserContactUpdateManyWithWhereWithoutContactInput = {
    where: UserContactScalarWhereInput
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyWithoutContactInput>
  }

  export type UserCreateWithoutPrekeyBundlesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutPrekeyBundlesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutPrekeyBundlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrekeyBundlesInput, UserUncheckedCreateWithoutPrekeyBundlesInput>
  }

  export type UserUpsertWithoutPrekeyBundlesInput = {
    update: XOR<UserUpdateWithoutPrekeyBundlesInput, UserUncheckedUpdateWithoutPrekeyBundlesInput>
    create: XOR<UserCreateWithoutPrekeyBundlesInput, UserUncheckedCreateWithoutPrekeyBundlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrekeyBundlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrekeyBundlesInput, UserUncheckedUpdateWithoutPrekeyBundlesInput>
  }

  export type UserUpdateWithoutPrekeyBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutPrekeyBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSignedPrekeysInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutSignedPrekeysInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutSignedPrekeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignedPrekeysInput, UserUncheckedCreateWithoutSignedPrekeysInput>
  }

  export type UserUpsertWithoutSignedPrekeysInput = {
    update: XOR<UserUpdateWithoutSignedPrekeysInput, UserUncheckedUpdateWithoutSignedPrekeysInput>
    create: XOR<UserCreateWithoutSignedPrekeysInput, UserUncheckedCreateWithoutSignedPrekeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSignedPrekeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSignedPrekeysInput, UserUncheckedUpdateWithoutSignedPrekeysInput>
  }

  export type UserUpdateWithoutSignedPrekeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutSignedPrekeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSessionStatesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutSessionStatesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutSessionStatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionStatesInput, UserUncheckedCreateWithoutSessionStatesInput>
  }

  export type UserUpsertWithoutSessionStatesInput = {
    update: XOR<UserUpdateWithoutSessionStatesInput, UserUncheckedUpdateWithoutSessionStatesInput>
    create: XOR<UserCreateWithoutSessionStatesInput, UserUncheckedCreateWithoutSessionStatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionStatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionStatesInput, UserUncheckedUpdateWithoutSessionStatesInput>
  }

  export type UserUpdateWithoutSessionStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type GroupCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    creatorId: string
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
  }

  export type MessageCreateWithoutRepliesInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
  }

  export type MessageCreateWithoutReplyToInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReplyToInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReplyToInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput>
  }

  export type MessageCreateManyReplyToInputEnvelope = {
    data: MessageCreateManyReplyToInput | MessageCreateManyReplyToInput[]
    skipDuplicates?: boolean
  }

  export type MediaFileCreateWithoutMessagesInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateWithoutMessagesInput = {
    id?: string
    uploaderId: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type MediaFileCreateOrConnectWithoutMessagesInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutMessagesInput, MediaFileUncheckedCreateWithoutMessagesInput>
  }

  export type SignalMessageMetadataCreateWithoutMessageInput = {
    id?: string
    cipherType: number
    deviceId: number
    senderKeyDistribution?: string | null
  }

  export type SignalMessageMetadataUncheckedCreateWithoutMessageInput = {
    id?: string
    cipherType: number
    deviceId: number
    senderKeyDistribution?: string | null
  }

  export type SignalMessageMetadataCreateOrConnectWithoutMessageInput = {
    where: SignalMessageMetadataWhereUniqueInput
    create: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
  }

  export type DeletedMessageCreateWithoutMessageInput = {
    id?: string
    deletedAt?: Date | string
    user: UserCreateNestedOneWithoutDeletedMessagesInput
  }

  export type DeletedMessageUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    deletedAt?: Date | string
  }

  export type DeletedMessageCreateOrConnectWithoutMessageInput = {
    where: DeletedMessageWhereUniqueInput
    create: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput>
  }

  export type DeletedMessageCreateManyMessageInputEnvelope = {
    data: DeletedMessageCreateManyMessageInput | DeletedMessageCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type GroupUpsertWithoutMessagesInput = {
    update: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type GroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MessageUpsertWithoutRepliesInput = {
    update: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutReplyToInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReplyToInput, MessageUncheckedUpdateWithoutReplyToInput>
    create: XOR<MessageCreateWithoutReplyToInput, MessageUncheckedCreateWithoutReplyToInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReplyToInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReplyToInput, MessageUncheckedUpdateWithoutReplyToInput>
  }

  export type MessageUpdateManyWithWhereWithoutReplyToInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReplyToInput>
  }

  export type MediaFileUpsertWithoutMessagesInput = {
    update: XOR<MediaFileUpdateWithoutMessagesInput, MediaFileUncheckedUpdateWithoutMessagesInput>
    create: XOR<MediaFileCreateWithoutMessagesInput, MediaFileUncheckedCreateWithoutMessagesInput>
    where?: MediaFileWhereInput
  }

  export type MediaFileUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MediaFileWhereInput
    data: XOR<MediaFileUpdateWithoutMessagesInput, MediaFileUncheckedUpdateWithoutMessagesInput>
  }

  export type MediaFileUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SignalMessageMetadataUpsertWithoutMessageInput = {
    update: XOR<SignalMessageMetadataUpdateWithoutMessageInput, SignalMessageMetadataUncheckedUpdateWithoutMessageInput>
    create: XOR<SignalMessageMetadataCreateWithoutMessageInput, SignalMessageMetadataUncheckedCreateWithoutMessageInput>
    where?: SignalMessageMetadataWhereInput
  }

  export type SignalMessageMetadataUpdateToOneWithWhereWithoutMessageInput = {
    where?: SignalMessageMetadataWhereInput
    data: XOR<SignalMessageMetadataUpdateWithoutMessageInput, SignalMessageMetadataUncheckedUpdateWithoutMessageInput>
  }

  export type SignalMessageMetadataUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignalMessageMetadataUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipherType?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    senderKeyDistribution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedMessageUpsertWithWhereUniqueWithoutMessageInput = {
    where: DeletedMessageWhereUniqueInput
    update: XOR<DeletedMessageUpdateWithoutMessageInput, DeletedMessageUncheckedUpdateWithoutMessageInput>
    create: XOR<DeletedMessageCreateWithoutMessageInput, DeletedMessageUncheckedCreateWithoutMessageInput>
  }

  export type DeletedMessageUpdateWithWhereUniqueWithoutMessageInput = {
    where: DeletedMessageWhereUniqueInput
    data: XOR<DeletedMessageUpdateWithoutMessageInput, DeletedMessageUncheckedUpdateWithoutMessageInput>
  }

  export type DeletedMessageUpdateManyWithWhereWithoutMessageInput = {
    where: DeletedMessageScalarWhereInput
    data: XOR<DeletedMessageUpdateManyMutationInput, DeletedMessageUncheckedUpdateManyWithoutMessageInput>
  }

  export type UserCreateWithoutCreatedGroupsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutGroupInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutGroupInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutGroupInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageCreateManyGroupInputEnvelope = {
    data: MessageCreateManyGroupInput | MessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type UserUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
  }

  export type MessageUpdateManyWithWhereWithoutGroupInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    creatorId: string
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembersInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutGroupMembersInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutGroupMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutGroupMembersInput = {
    update: XOR<UserUpdateWithoutGroupMembersInput, UserUncheckedUpdateWithoutGroupMembersInput>
    create: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembersInput, UserUncheckedUpdateWithoutGroupMembersInput>
  }

  export type UserUpdateWithoutGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutOwnedContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutOwnedContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutOwnedContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
  }

  export type UserCreateWithoutContactedByInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutContactedByInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutContactedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactedByInput, UserUncheckedCreateWithoutContactedByInput>
  }

  export type UserUpsertWithoutOwnedContactsInput = {
    update: XOR<UserUpdateWithoutOwnedContactsInput, UserUncheckedUpdateWithoutOwnedContactsInput>
    create: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedContactsInput, UserUncheckedUpdateWithoutOwnedContactsInput>
  }

  export type UserUpdateWithoutOwnedContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutContactedByInput = {
    update: XOR<UserUpdateWithoutContactedByInput, UserUncheckedUpdateWithoutContactedByInput>
    create: XOR<UserCreateWithoutContactedByInput, UserUncheckedCreateWithoutContactedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactedByInput, UserUncheckedUpdateWithoutContactedByInput>
  }

  export type UserUpdateWithoutContactedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutContactedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutMediaFilesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutMediaFilesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutMediaFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
  }

  export type MessageCreateWithoutMediaFileInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutMediaFileInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutMediaFileInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput>
  }

  export type MessageCreateManyMediaFileInputEnvelope = {
    data: MessageCreateManyMediaFileInput | MessageCreateManyMediaFileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMediaFilesInput = {
    update: XOR<UserUpdateWithoutMediaFilesInput, UserUncheckedUpdateWithoutMediaFilesInput>
    create: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaFilesInput, UserUncheckedUpdateWithoutMediaFilesInput>
  }

  export type UserUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutMediaFileInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutMediaFileInput, MessageUncheckedUpdateWithoutMediaFileInput>
    create: XOR<MessageCreateWithoutMediaFileInput, MessageUncheckedCreateWithoutMediaFileInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutMediaFileInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutMediaFileInput, MessageUncheckedUpdateWithoutMediaFileInput>
  }

  export type MessageUpdateManyWithWhereWithoutMediaFileInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMediaFileInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutOtpAttemptsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutOtpAttemptsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutOtpAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpAttemptsInput, UserUncheckedCreateWithoutOtpAttemptsInput>
  }

  export type UserUpsertWithoutOtpAttemptsInput = {
    update: XOR<UserUpdateWithoutOtpAttemptsInput, UserUncheckedUpdateWithoutOtpAttemptsInput>
    create: XOR<UserCreateWithoutOtpAttemptsInput, UserUncheckedCreateWithoutOtpAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpAttemptsInput, UserUncheckedUpdateWithoutOtpAttemptsInput>
  }

  export type UserUpdateWithoutOtpAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSignalIdentitiesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutSignalIdentitiesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutSignalIdentitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignalIdentitiesInput, UserUncheckedCreateWithoutSignalIdentitiesInput>
  }

  export type UserUpsertWithoutSignalIdentitiesInput = {
    update: XOR<UserUpdateWithoutSignalIdentitiesInput, UserUncheckedUpdateWithoutSignalIdentitiesInput>
    create: XOR<UserCreateWithoutSignalIdentitiesInput, UserUncheckedCreateWithoutSignalIdentitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSignalIdentitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSignalIdentitiesInput, UserUncheckedUpdateWithoutSignalIdentitiesInput>
  }

  export type UserUpdateWithoutSignalIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutSignalIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageCreateWithoutSignalMetadataInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSignalMetadataInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSignalMetadataInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSignalMetadataInput, MessageUncheckedCreateWithoutSignalMetadataInput>
  }

  export type MessageUpsertWithoutSignalMetadataInput = {
    update: XOR<MessageUpdateWithoutSignalMetadataInput, MessageUncheckedUpdateWithoutSignalMetadataInput>
    create: XOR<MessageCreateWithoutSignalMetadataInput, MessageUncheckedCreateWithoutSignalMetadataInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutSignalMetadataInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutSignalMetadataInput, MessageUncheckedUpdateWithoutSignalMetadataInput>
  }

  export type MessageUpdateWithoutSignalMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSignalMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserCreateWithoutUserContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutUserContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutUserContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserContactsInput, UserUncheckedCreateWithoutUserContactsInput>
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    deletedMessages?: DeletedMessageUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutUserContactsInput = {
    update: XOR<UserUpdateWithoutUserContactsInput, UserUncheckedUpdateWithoutUserContactsInput>
    create: XOR<UserCreateWithoutUserContactsInput, UserUncheckedCreateWithoutUserContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserContactsInput, UserUncheckedUpdateWithoutUserContactsInput>
  }

  export type UserUpdateWithoutUserContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutUserContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageCreateWithoutDeletedMessagesInput = {
    id?: string
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient?: UserCreateNestedOneWithoutReceivedMessagesInput
    group?: GroupCreateNestedOneWithoutMessagesInput
    replyTo?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutReplyToInput
    mediaFile?: MediaFileCreateNestedOneWithoutMessagesInput
    signalMetadata?: SignalMessageMetadataCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutDeletedMessagesInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutReplyToInput
    signalMetadata?: SignalMessageMetadataUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutDeletedMessagesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutDeletedMessagesInput, MessageUncheckedCreateWithoutDeletedMessagesInput>
  }

  export type UserCreateWithoutDeletedMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    userContacts?: ContactCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactCreateNestedManyWithoutContactInput
  }

  export type UserUncheckedCreateWithoutDeletedMessagesInput = {
    id?: string
    phoneNumber: string
    countryCode: string
    identityKey: string
    registrationId: number
    name?: string | null
    about?: string | null
    avatarUrl?: string | null
    isOnline?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    prekeyBundles?: PrekeyBundleUncheckedCreateNestedManyWithoutUserInput
    signedPrekeys?: SignedPrekeyUncheckedCreateNestedManyWithoutUserInput
    signalIdentities?: SignalIdentityUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    userContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutContactUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUploaderInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    otpAttempts?: OtpAttemptUncheckedCreateNestedManyWithoutUserInput
    sessionStates?: SessionStateUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: UserContactUncheckedCreateNestedManyWithoutOwnerInput
    contactedBy?: UserContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type UserCreateOrConnectWithoutDeletedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedMessagesInput, UserUncheckedCreateWithoutDeletedMessagesInput>
  }

  export type MessageUpsertWithoutDeletedMessagesInput = {
    update: XOR<MessageUpdateWithoutDeletedMessagesInput, MessageUncheckedUpdateWithoutDeletedMessagesInput>
    create: XOR<MessageCreateWithoutDeletedMessagesInput, MessageUncheckedCreateWithoutDeletedMessagesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutDeletedMessagesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutDeletedMessagesInput, MessageUncheckedUpdateWithoutDeletedMessagesInput>
  }

  export type MessageUpdateWithoutDeletedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutDeletedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type UserUpsertWithoutDeletedMessagesInput = {
    update: XOR<UserUpdateWithoutDeletedMessagesInput, UserUncheckedUpdateWithoutDeletedMessagesInput>
    create: XOR<UserCreateWithoutDeletedMessagesInput, UserUncheckedCreateWithoutDeletedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletedMessagesInput, UserUncheckedUpdateWithoutDeletedMessagesInput>
  }

  export type UserUpdateWithoutDeletedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUpdateManyWithoutContactNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    identityKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    prekeyBundles?: PrekeyBundleUncheckedUpdateManyWithoutUserNestedInput
    signedPrekeys?: SignedPrekeyUncheckedUpdateManyWithoutUserNestedInput
    signalIdentities?: SignalIdentityUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    userContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutContactUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUploaderNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    otpAttempts?: OtpAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessionStates?: SessionStateUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: UserContactUncheckedUpdateManyWithoutOwnerNestedInput
    contactedBy?: UserContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageCreateManySenderInput = {
    id?: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyRecipientInput = {
    id?: string
    senderId: string
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrekeyBundleCreateManyUserInput = {
    id?: number
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type SignedPrekeyCreateManyUserInput = {
    id?: number
    deviceId?: number
    keyId: number
    publicKey: string
    signature: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SignalIdentityCreateManyUserInput = {
    id?: string
    deviceId: number
    identityPublicKey: string
    identityPrivateKey: string
    registrationId: number
    createdAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    senderKeyDistribution?: Buffer | null
    isPublic?: boolean
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: string
    contactUserId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type ContactCreateManyContactUserInput = {
    id?: string
    userId: string
    customName?: string | null
    isBlocked?: boolean
    isMuted?: boolean
    addedAt?: Date | string
  }

  export type MediaFileCreateManyUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    mediaType?: $Enums.MediaType | null
    isUploaded?: boolean
    uploadedAt?: Date | string | null
    encryptionKey?: string | null
    s3Key: string
    s3Bucket: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    isRevoked?: boolean
  }

  export type OtpAttemptCreateManyUserInput = {
    id?: string
    phoneNumber: string
    otpCode: string
    attempts?: number
    isVerified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type DeletedMessageCreateManyUserInput = {
    id?: string
    messageId: string
    deletedAt?: Date | string
  }

  export type SessionStateCreateManyUserInput = {
    id?: string
    remoteUserId: string
    sessionData: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserContactCreateManyOwnerInput = {
    id?: string
    contactId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type UserContactCreateManyContactInput = {
    id?: string
    ownerId: string
    name?: string | null
    isBlocked?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleUpdateWithoutUserInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrekeyBundleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyUpdateWithoutUserInput = {
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignedPrekeyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    keyId?: IntFieldUpdateOperationsInput | number
    publicKey?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalIdentityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalIdentityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalIdentityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    identityPublicKey?: StringFieldUpdateOperationsInput | string
    identityPrivateKey?: StringFieldUpdateOperationsInput | string
    registrationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    senderKeyDistribution?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactUser?: UserUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactUserId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactUserId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutContactUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutContactUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutMediaFileNestedInput
  }

  export type MediaFileUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutMediaFileNestedInput
  }

  export type MediaFileUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptionKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutDeletedMessagesNestedInput
  }

  export type DeletedMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteUserId?: StringFieldUpdateOperationsInput | string
    sessionData?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: UserUpdateOneRequiredWithoutContactedByNestedInput
  }

  export type UserContactUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
  }

  export type UserContactUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyReplyToInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeletedMessageCreateManyMessageInput = {
    id?: string
    userId: string
    deletedAt?: Date | string
  }

  export type MessageUpdateWithoutReplyToInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReplyToInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutReplyToInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeletedMessagesNestedInput
  }

  export type DeletedMessageUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeletedMessageUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type MessageCreateManyGroupInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    mediaFileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    mediaFile?: MediaFileUpdateOneWithoutMessagesNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    mediaFileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyMediaFileInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    groupId?: string | null
    encryptedContent: Buffer
    messageType?: $Enums.MessageType
    timestamp: bigint | number
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.MessageStatus
    isDeleted?: boolean
    deletedAt?: Date | string | null
    replyToId?: string | null
    isForwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutMediaFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneWithoutReceivedMessagesNestedInput
    group?: GroupUpdateOneWithoutMessagesNestedInput
    replyTo?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutMediaFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutReplyToNestedInput
    signalMetadata?: SignalMessageMetadataUncheckedUpdateOneWithoutMessageNestedInput
    deletedMessages?: DeletedMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutMediaFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Buffer
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyToId?: NullableStringFieldUpdateOperationsInput | string | null
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaFileCountOutputTypeDefaultArgs instead
     */
    export type MediaFileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaFileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrekeyBundleDefaultArgs instead
     */
    export type PrekeyBundleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrekeyBundleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignedPrekeyDefaultArgs instead
     */
    export type SignedPrekeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignedPrekeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionStateDefaultArgs instead
     */
    export type SessionStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupMemberDefaultArgs instead
     */
    export type GroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserContactDefaultArgs instead
     */
    export type UserContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaFileDefaultArgs instead
     */
    export type MediaFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtpAttemptDefaultArgs instead
     */
    export type OtpAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtpAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignalIdentityDefaultArgs instead
     */
    export type SignalIdentityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignalIdentityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignalSessionDefaultArgs instead
     */
    export type SignalSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignalSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SenderKeyDefaultArgs instead
     */
    export type SenderKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SenderKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignalMessageMetadataDefaultArgs instead
     */
    export type SignalMessageMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignalMessageMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeletedMessageDefaultArgs instead
     */
    export type DeletedMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeletedMessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}